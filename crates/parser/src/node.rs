// src/nodes.rs is autogeneratd from templates/nodes.rs

use crop::Rope;
use tree_sitter::Node;
use stdx::{TextRange, WithTR};
use lazy_static::lazy_static;

use crate::text_of;

// for w/e reasons looking up the child by field_name doesn't work
// so we filter on kind
lazy_static!{
    pub static ref AdditiveExpressionId: u16 = crate::LANGUAGE.id_for_node_kind("additive_expression", true);
}
pub struct AdditiveExpression<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> AdditiveExpression<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for AdditiveExpression<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref AnnotatedLambdaId: u16 = crate::LANGUAGE.id_for_node_kind("annotated_lambda", true);
}
pub struct AnnotatedLambda<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> AnnotatedLambda<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_annotation(&self) -> Option<Annotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "annotation")
            .map(|n| Annotation::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_annotation(&self) -> Vec<Annotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "annotation")
            .map(|n| Annotation::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_label(&self) -> Option<Label> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "label")
            .map(|n| Label::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_label(&self) -> Vec<Label> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "label")
            .map(|n| Label::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for AnnotatedLambda<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref AnnotationId: u16 = crate::LANGUAGE.id_for_node_kind("annotation", true);
}
pub struct Annotation<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> Annotation<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_constructor_invocation(&self) -> Option<ConstructorInvocation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "constructor_invocation")
            .map(|n| ConstructorInvocation::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_constructor_invocation(&self) -> Vec<ConstructorInvocation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "constructor_invocation")
            .map(|n| ConstructorInvocation::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_use_site_target(&self) -> Option<UseSiteTarget> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "use_site_target")
            .map(|n| UseSiteTarget::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_use_site_target(&self) -> Vec<UseSiteTarget> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "use_site_target")
            .map(|n| UseSiteTarget::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_user_type(&self) -> Option<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "user_type")
            .map(|n| UserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_user_type(&self) -> Vec<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "user_type")
            .map(|n| UserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for Annotation<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref AnonymousFunctionId: u16 = crate::LANGUAGE.id_for_node_kind("anonymous_function", true);
}
pub struct AnonymousFunction<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> AnonymousFunction<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_function_body(&self) -> Option<FunctionBody> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_body")
            .map(|n| FunctionBody::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_body(&self) -> Vec<FunctionBody> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_body")
            .map(|n| FunctionBody::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_function_type(&self) -> Option<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_type")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_type(&self) -> Vec<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_type")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_function_value_parameters(&self) -> Option<FunctionValueParameters> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_value_parameters")
            .map(|n| FunctionValueParameters::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_value_parameters(&self) -> Vec<FunctionValueParameters> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_value_parameters")
            .map(|n| FunctionValueParameters::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_not_nullable_type(&self) -> Option<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "not_nullable_type")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_not_nullable_type(&self) -> Vec<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "not_nullable_type")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_nullable_type(&self) -> Option<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "nullable_type")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_nullable_type(&self) -> Vec<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "nullable_type")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_type(&self) -> Option<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_type")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_type(&self) -> Vec<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_type")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_arguments(&self) -> Option<TypeArguments> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_arguments")
            .map(|n| TypeArguments::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_arguments(&self) -> Vec<TypeArguments> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_arguments")
            .map(|n| TypeArguments::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_identifier(&self) -> Option<TypeIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_identifier(&self) -> Vec<TypeIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_modifiers(&self) -> Option<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_modifiers")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_modifiers(&self) -> Vec<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_modifiers")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_user_type(&self) -> Option<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "user_type")
            .map(|n| UserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_user_type(&self) -> Vec<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "user_type")
            .map(|n| UserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for AnonymousFunction<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref AnonymousInitializerId: u16 = crate::LANGUAGE.id_for_node_kind("anonymous_initializer", true);
}
pub struct AnonymousInitializer<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> AnonymousInitializer<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_statements(&self) -> Option<Statements> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "statements")
            .map(|n| Statements::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_statements(&self) -> Vec<Statements> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "statements")
            .map(|n| Statements::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for AnonymousInitializer<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref AsExpressionId: u16 = crate::LANGUAGE.id_for_node_kind("as_expression", true);
}
pub struct AsExpression<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> AsExpression<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_function_type(&self) -> Option<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_type")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_type(&self) -> Vec<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_type")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_not_nullable_type(&self) -> Option<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "not_nullable_type")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_not_nullable_type(&self) -> Vec<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "not_nullable_type")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_nullable_type(&self) -> Option<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "nullable_type")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_nullable_type(&self) -> Vec<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "nullable_type")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_type(&self) -> Option<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_type")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_type(&self) -> Vec<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_type")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_modifiers(&self) -> Option<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_modifiers")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_modifiers(&self) -> Vec<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_modifiers")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_user_type(&self) -> Option<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "user_type")
            .map(|n| UserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_user_type(&self) -> Vec<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "user_type")
            .map(|n| UserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for AsExpression<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref AssignmentId: u16 = crate::LANGUAGE.id_for_node_kind("assignment", true);
}
pub struct Assignment<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> Assignment<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_directly_assignable_expression(&self) -> Option<DirectlyAssignableExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "directly_assignable_expression")
            .map(|n| DirectlyAssignableExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_directly_assignable_expression(&self) -> Vec<DirectlyAssignableExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "directly_assignable_expression")
            .map(|n| DirectlyAssignableExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for Assignment<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref BindingPatternKindId: u16 = crate::LANGUAGE.id_for_node_kind("binding_pattern_kind", true);
}
pub struct BindingPatternKind<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> BindingPatternKind<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }}

impl<'a> std::fmt::Debug for BindingPatternKind<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref BooleanLiteralId: u16 = crate::LANGUAGE.id_for_node_kind("boolean_literal", true);
}
pub struct BooleanLiteral<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> BooleanLiteral<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }}

impl<'a> std::fmt::Debug for BooleanLiteral<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref CallExpressionId: u16 = crate::LANGUAGE.id_for_node_kind("call_expression", true);
}
pub struct CallExpression<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> CallExpression<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_suffix(&self) -> Option<CallSuffix> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_suffix")
            .map(|n| CallSuffix::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_suffix(&self) -> Vec<CallSuffix> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_suffix")
            .map(|n| CallSuffix::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for CallExpression<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref CallSuffixId: u16 = crate::LANGUAGE.id_for_node_kind("call_suffix", true);
}
pub struct CallSuffix<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> CallSuffix<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_annotated_lambda(&self) -> Option<AnnotatedLambda> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "annotated_lambda")
            .map(|n| AnnotatedLambda::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_annotated_lambda(&self) -> Vec<AnnotatedLambda> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "annotated_lambda")
            .map(|n| AnnotatedLambda::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_arguments(&self) -> Option<TypeArguments> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_arguments")
            .map(|n| TypeArguments::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_arguments(&self) -> Vec<TypeArguments> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_arguments")
            .map(|n| TypeArguments::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_value_arguments(&self) -> Option<ValueArguments> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "value_arguments")
            .map(|n| ValueArguments::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_value_arguments(&self) -> Vec<ValueArguments> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "value_arguments")
            .map(|n| ValueArguments::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for CallSuffix<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref CallableReferenceId: u16 = crate::LANGUAGE.id_for_node_kind("callable_reference", true);
}
pub struct CallableReference<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> CallableReference<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_identifier(&self) -> Option<TypeIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_identifier(&self) -> Vec<TypeIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for CallableReference<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref CatchBlockId: u16 = crate::LANGUAGE.id_for_node_kind("catch_block", true);
}
pub struct CatchBlock<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> CatchBlock<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_annotation(&self) -> Option<Annotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "annotation")
            .map(|n| Annotation::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_annotation(&self) -> Vec<Annotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "annotation")
            .map(|n| Annotation::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_function_type(&self) -> Option<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_type")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_type(&self) -> Vec<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_type")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_not_nullable_type(&self) -> Option<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "not_nullable_type")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_not_nullable_type(&self) -> Vec<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "not_nullable_type")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_nullable_type(&self) -> Option<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "nullable_type")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_nullable_type(&self) -> Vec<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "nullable_type")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_type(&self) -> Option<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_type")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_type(&self) -> Vec<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_type")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_statements(&self) -> Option<Statements> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "statements")
            .map(|n| Statements::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_statements(&self) -> Vec<Statements> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "statements")
            .map(|n| Statements::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_modifiers(&self) -> Option<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_modifiers")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_modifiers(&self) -> Vec<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_modifiers")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_user_type(&self) -> Option<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "user_type")
            .map(|n| UserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_user_type(&self) -> Vec<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "user_type")
            .map(|n| UserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for CatchBlock<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref CharacterEscapeSeqId: u16 = crate::LANGUAGE.id_for_node_kind("character_escape_seq", true);
}
pub struct CharacterEscapeSeq<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> CharacterEscapeSeq<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }}

impl<'a> std::fmt::Debug for CharacterEscapeSeq<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref CharacterLiteralId: u16 = crate::LANGUAGE.id_for_node_kind("character_literal", true);
}
pub struct CharacterLiteral<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> CharacterLiteral<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_character_escape_seq(&self) -> Option<CharacterEscapeSeq> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_escape_seq")
            .map(|n| CharacterEscapeSeq::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_escape_seq(&self) -> Vec<CharacterEscapeSeq> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_escape_seq")
            .map(|n| CharacterEscapeSeq::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for CharacterLiteral<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref CheckExpressionId: u16 = crate::LANGUAGE.id_for_node_kind("check_expression", true);
}
pub struct CheckExpression<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> CheckExpression<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_function_type(&self) -> Option<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_type")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_type(&self) -> Vec<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_type")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_not_nullable_type(&self) -> Option<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "not_nullable_type")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_not_nullable_type(&self) -> Vec<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "not_nullable_type")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_nullable_type(&self) -> Option<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "nullable_type")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_nullable_type(&self) -> Vec<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "nullable_type")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_type(&self) -> Option<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_type")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_type(&self) -> Vec<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_type")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_modifiers(&self) -> Option<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_modifiers")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_modifiers(&self) -> Vec<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_modifiers")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_user_type(&self) -> Option<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "user_type")
            .map(|n| UserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_user_type(&self) -> Vec<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "user_type")
            .map(|n| UserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for CheckExpression<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref ClassBodyId: u16 = crate::LANGUAGE.id_for_node_kind("class_body", true);
}
pub struct ClassBody<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> ClassBody<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_anonymous_initializer(&self) -> Option<AnonymousInitializer> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_initializer")
            .map(|n| AnonymousInitializer::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_initializer(&self) -> Vec<AnonymousInitializer> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_initializer")
            .map(|n| AnonymousInitializer::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_class_declaration(&self) -> Option<ClassDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "class_declaration")
            .map(|n| ClassDeclaration::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_class_declaration(&self) -> Vec<ClassDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "class_declaration")
            .map(|n| ClassDeclaration::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_companion_object(&self) -> Option<CompanionObject> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "companion_object")
            .map(|n| CompanionObject::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_companion_object(&self) -> Vec<CompanionObject> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "companion_object")
            .map(|n| CompanionObject::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_function_declaration(&self) -> Option<FunctionDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_declaration")
            .map(|n| FunctionDeclaration::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_declaration(&self) -> Vec<FunctionDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_declaration")
            .map(|n| FunctionDeclaration::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_getter(&self) -> Option<Getter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "getter")
            .map(|n| Getter::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_getter(&self) -> Vec<Getter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "getter")
            .map(|n| Getter::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_declaration(&self) -> Option<ObjectDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_declaration")
            .map(|n| ObjectDeclaration::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_declaration(&self) -> Vec<ObjectDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_declaration")
            .map(|n| ObjectDeclaration::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_property_declaration(&self) -> Option<PropertyDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "property_declaration")
            .map(|n| PropertyDeclaration::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_property_declaration(&self) -> Vec<PropertyDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "property_declaration")
            .map(|n| PropertyDeclaration::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_secondary_constructor(&self) -> Option<SecondaryConstructor> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "secondary_constructor")
            .map(|n| SecondaryConstructor::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_secondary_constructor(&self) -> Vec<SecondaryConstructor> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "secondary_constructor")
            .map(|n| SecondaryConstructor::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_setter(&self) -> Option<Setter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "setter")
            .map(|n| Setter::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_setter(&self) -> Vec<Setter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "setter")
            .map(|n| Setter::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_alias(&self) -> Option<TypeAlias> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_alias")
            .map(|n| TypeAlias::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_alias(&self) -> Vec<TypeAlias> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_alias")
            .map(|n| TypeAlias::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for ClassBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref ClassDeclarationId: u16 = crate::LANGUAGE.id_for_node_kind("class_declaration", true);
}
pub struct ClassDeclaration<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> ClassDeclaration<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_class_body(&self) -> Option<ClassBody> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "class_body")
            .map(|n| ClassBody::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_class_body(&self) -> Vec<ClassBody> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "class_body")
            .map(|n| ClassBody::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_delegation_specifier(&self) -> Option<DelegationSpecifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "delegation_specifier")
            .map(|n| DelegationSpecifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_delegation_specifier(&self) -> Vec<DelegationSpecifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "delegation_specifier")
            .map(|n| DelegationSpecifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_enum_class_body(&self) -> Option<EnumClassBody> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "enum_class_body")
            .map(|n| EnumClassBody::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_enum_class_body(&self) -> Vec<EnumClassBody> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "enum_class_body")
            .map(|n| EnumClassBody::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_modifiers(&self) -> Option<Modifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "modifiers")
            .map(|n| Modifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_modifiers(&self) -> Vec<Modifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "modifiers")
            .map(|n| Modifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_primary_constructor(&self) -> Option<PrimaryConstructor> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "primary_constructor")
            .map(|n| PrimaryConstructor::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_primary_constructor(&self) -> Vec<PrimaryConstructor> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "primary_constructor")
            .map(|n| PrimaryConstructor::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_constraints(&self) -> Option<TypeConstraints> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_constraints")
            .map(|n| TypeConstraints::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_constraints(&self) -> Vec<TypeConstraints> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_constraints")
            .map(|n| TypeConstraints::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_identifier(&self) -> Option<TypeIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_identifier(&self) -> Vec<TypeIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_parameters(&self) -> Option<TypeParameters> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_parameters")
            .map(|n| TypeParameters::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_parameters(&self) -> Vec<TypeParameters> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_parameters")
            .map(|n| TypeParameters::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for ClassDeclaration<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref ClassModifierId: u16 = crate::LANGUAGE.id_for_node_kind("class_modifier", true);
}
pub struct ClassModifier<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> ClassModifier<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }}

impl<'a> std::fmt::Debug for ClassModifier<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref ClassParameterId: u16 = crate::LANGUAGE.id_for_node_kind("class_parameter", true);
}
pub struct ClassParameter<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> ClassParameter<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_binding_pattern_kind(&self) -> Option<BindingPatternKind> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "binding_pattern_kind")
            .map(|n| BindingPatternKind::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_binding_pattern_kind(&self) -> Vec<BindingPatternKind> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "binding_pattern_kind")
            .map(|n| BindingPatternKind::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_function_type(&self) -> Option<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_type")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_type(&self) -> Vec<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_type")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_modifiers(&self) -> Option<Modifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "modifiers")
            .map(|n| Modifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_modifiers(&self) -> Vec<Modifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "modifiers")
            .map(|n| Modifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_not_nullable_type(&self) -> Option<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "not_nullable_type")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_not_nullable_type(&self) -> Vec<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "not_nullable_type")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_nullable_type(&self) -> Option<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "nullable_type")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_nullable_type(&self) -> Vec<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "nullable_type")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_type(&self) -> Option<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_type")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_type(&self) -> Vec<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_type")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_modifiers(&self) -> Option<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_modifiers")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_modifiers(&self) -> Vec<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_modifiers")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_user_type(&self) -> Option<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "user_type")
            .map(|n| UserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_user_type(&self) -> Vec<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "user_type")
            .map(|n| UserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for ClassParameter<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref CollectionLiteralId: u16 = crate::LANGUAGE.id_for_node_kind("collection_literal", true);
}
pub struct CollectionLiteral<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> CollectionLiteral<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for CollectionLiteral<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref CompanionObjectId: u16 = crate::LANGUAGE.id_for_node_kind("companion_object", true);
}
pub struct CompanionObject<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> CompanionObject<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_class_body(&self) -> Option<ClassBody> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "class_body")
            .map(|n| ClassBody::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_class_body(&self) -> Vec<ClassBody> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "class_body")
            .map(|n| ClassBody::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_delegation_specifier(&self) -> Option<DelegationSpecifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "delegation_specifier")
            .map(|n| DelegationSpecifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_delegation_specifier(&self) -> Vec<DelegationSpecifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "delegation_specifier")
            .map(|n| DelegationSpecifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_modifiers(&self) -> Option<Modifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "modifiers")
            .map(|n| Modifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_modifiers(&self) -> Vec<Modifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "modifiers")
            .map(|n| Modifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_identifier(&self) -> Option<TypeIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_identifier(&self) -> Vec<TypeIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for CompanionObject<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref ComparisonExpressionId: u16 = crate::LANGUAGE.id_for_node_kind("comparison_expression", true);
}
pub struct ComparisonExpression<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> ComparisonExpression<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for ComparisonExpression<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref ConjunctionExpressionId: u16 = crate::LANGUAGE.id_for_node_kind("conjunction_expression", true);
}
pub struct ConjunctionExpression<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> ConjunctionExpression<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for ConjunctionExpression<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref ConstructorDelegationCallId: u16 = crate::LANGUAGE.id_for_node_kind("constructor_delegation_call", true);
}
pub struct ConstructorDelegationCall<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> ConstructorDelegationCall<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_value_arguments(&self) -> Option<ValueArguments> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "value_arguments")
            .map(|n| ValueArguments::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_value_arguments(&self) -> Vec<ValueArguments> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "value_arguments")
            .map(|n| ValueArguments::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for ConstructorDelegationCall<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref ConstructorInvocationId: u16 = crate::LANGUAGE.id_for_node_kind("constructor_invocation", true);
}
pub struct ConstructorInvocation<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> ConstructorInvocation<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_user_type(&self) -> Option<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "user_type")
            .map(|n| UserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_user_type(&self) -> Vec<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "user_type")
            .map(|n| UserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_value_arguments(&self) -> Option<ValueArguments> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "value_arguments")
            .map(|n| ValueArguments::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_value_arguments(&self) -> Vec<ValueArguments> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "value_arguments")
            .map(|n| ValueArguments::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for ConstructorInvocation<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref ControlStructureBodyId: u16 = crate::LANGUAGE.id_for_node_kind("control_structure_body", true);
}
pub struct ControlStructureBody<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> ControlStructureBody<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_annotation(&self) -> Option<Annotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "annotation")
            .map(|n| Annotation::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_annotation(&self) -> Vec<Annotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "annotation")
            .map(|n| Annotation::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_assignment(&self) -> Option<Assignment> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "assignment")
            .map(|n| Assignment::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_assignment(&self) -> Vec<Assignment> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "assignment")
            .map(|n| Assignment::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_class_declaration(&self) -> Option<ClassDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "class_declaration")
            .map(|n| ClassDeclaration::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_class_declaration(&self) -> Vec<ClassDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "class_declaration")
            .map(|n| ClassDeclaration::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_do_while_statement(&self) -> Option<DoWhileStatement> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "do_while_statement")
            .map(|n| DoWhileStatement::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_do_while_statement(&self) -> Vec<DoWhileStatement> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "do_while_statement")
            .map(|n| DoWhileStatement::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_for_statement(&self) -> Option<ForStatement> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "for_statement")
            .map(|n| ForStatement::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_for_statement(&self) -> Vec<ForStatement> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "for_statement")
            .map(|n| ForStatement::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_function_declaration(&self) -> Option<FunctionDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_declaration")
            .map(|n| FunctionDeclaration::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_declaration(&self) -> Vec<FunctionDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_declaration")
            .map(|n| FunctionDeclaration::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_getter(&self) -> Option<Getter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "getter")
            .map(|n| Getter::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_getter(&self) -> Vec<Getter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "getter")
            .map(|n| Getter::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_label(&self) -> Option<Label> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "label")
            .map(|n| Label::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_label(&self) -> Vec<Label> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "label")
            .map(|n| Label::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_declaration(&self) -> Option<ObjectDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_declaration")
            .map(|n| ObjectDeclaration::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_declaration(&self) -> Vec<ObjectDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_declaration")
            .map(|n| ObjectDeclaration::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_property_declaration(&self) -> Option<PropertyDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "property_declaration")
            .map(|n| PropertyDeclaration::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_property_declaration(&self) -> Vec<PropertyDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "property_declaration")
            .map(|n| PropertyDeclaration::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_setter(&self) -> Option<Setter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "setter")
            .map(|n| Setter::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_setter(&self) -> Vec<Setter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "setter")
            .map(|n| Setter::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_statements(&self) -> Option<Statements> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "statements")
            .map(|n| Statements::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_statements(&self) -> Vec<Statements> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "statements")
            .map(|n| Statements::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_alias(&self) -> Option<TypeAlias> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_alias")
            .map(|n| TypeAlias::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_alias(&self) -> Vec<TypeAlias> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_alias")
            .map(|n| TypeAlias::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_while_statement(&self) -> Option<WhileStatement> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "while_statement")
            .map(|n| WhileStatement::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_while_statement(&self) -> Vec<WhileStatement> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "while_statement")
            .map(|n| WhileStatement::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for ControlStructureBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref DelegationSpecifierId: u16 = crate::LANGUAGE.id_for_node_kind("delegation_specifier", true);
}
pub struct DelegationSpecifier<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> DelegationSpecifier<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_constructor_invocation(&self) -> Option<ConstructorInvocation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "constructor_invocation")
            .map(|n| ConstructorInvocation::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_constructor_invocation(&self) -> Vec<ConstructorInvocation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "constructor_invocation")
            .map(|n| ConstructorInvocation::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_explicit_delegation(&self) -> Option<ExplicitDelegation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "explicit_delegation")
            .map(|n| ExplicitDelegation::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_explicit_delegation(&self) -> Vec<ExplicitDelegation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "explicit_delegation")
            .map(|n| ExplicitDelegation::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_function_type(&self) -> Option<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_type")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_type(&self) -> Vec<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_type")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_user_type(&self) -> Option<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "user_type")
            .map(|n| UserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_user_type(&self) -> Vec<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "user_type")
            .map(|n| UserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for DelegationSpecifier<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref DirectlyAssignableExpressionId: u16 = crate::LANGUAGE.id_for_node_kind("directly_assignable_expression", true);
}
pub struct DirectlyAssignableExpression<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> DirectlyAssignableExpression<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_suffix(&self) -> Option<IndexingSuffix> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_suffix")
            .map(|n| IndexingSuffix::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_suffix(&self) -> Vec<IndexingSuffix> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_suffix")
            .map(|n| IndexingSuffix::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_suffix(&self) -> Option<NavigationSuffix> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_suffix")
            .map(|n| NavigationSuffix::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_suffix(&self) -> Vec<NavigationSuffix> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_suffix")
            .map(|n| NavigationSuffix::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for DirectlyAssignableExpression<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref DisjunctionExpressionId: u16 = crate::LANGUAGE.id_for_node_kind("disjunction_expression", true);
}
pub struct DisjunctionExpression<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> DisjunctionExpression<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for DisjunctionExpression<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref DoWhileStatementId: u16 = crate::LANGUAGE.id_for_node_kind("do_while_statement", true);
}
pub struct DoWhileStatement<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> DoWhileStatement<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_control_structure_body(&self) -> Option<ControlStructureBody> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "control_structure_body")
            .map(|n| ControlStructureBody::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_control_structure_body(&self) -> Vec<ControlStructureBody> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "control_structure_body")
            .map(|n| ControlStructureBody::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for DoWhileStatement<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref ElvisExpressionId: u16 = crate::LANGUAGE.id_for_node_kind("elvis_expression", true);
}
pub struct ElvisExpression<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> ElvisExpression<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for ElvisExpression<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref EnumClassBodyId: u16 = crate::LANGUAGE.id_for_node_kind("enum_class_body", true);
}
pub struct EnumClassBody<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> EnumClassBody<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_anonymous_initializer(&self) -> Option<AnonymousInitializer> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_initializer")
            .map(|n| AnonymousInitializer::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_initializer(&self) -> Vec<AnonymousInitializer> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_initializer")
            .map(|n| AnonymousInitializer::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_class_declaration(&self) -> Option<ClassDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "class_declaration")
            .map(|n| ClassDeclaration::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_class_declaration(&self) -> Vec<ClassDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "class_declaration")
            .map(|n| ClassDeclaration::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_companion_object(&self) -> Option<CompanionObject> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "companion_object")
            .map(|n| CompanionObject::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_companion_object(&self) -> Vec<CompanionObject> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "companion_object")
            .map(|n| CompanionObject::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_enum_entry(&self) -> Option<EnumEntry> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "enum_entry")
            .map(|n| EnumEntry::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_enum_entry(&self) -> Vec<EnumEntry> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "enum_entry")
            .map(|n| EnumEntry::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_function_declaration(&self) -> Option<FunctionDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_declaration")
            .map(|n| FunctionDeclaration::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_declaration(&self) -> Vec<FunctionDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_declaration")
            .map(|n| FunctionDeclaration::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_getter(&self) -> Option<Getter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "getter")
            .map(|n| Getter::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_getter(&self) -> Vec<Getter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "getter")
            .map(|n| Getter::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_declaration(&self) -> Option<ObjectDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_declaration")
            .map(|n| ObjectDeclaration::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_declaration(&self) -> Vec<ObjectDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_declaration")
            .map(|n| ObjectDeclaration::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_property_declaration(&self) -> Option<PropertyDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "property_declaration")
            .map(|n| PropertyDeclaration::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_property_declaration(&self) -> Vec<PropertyDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "property_declaration")
            .map(|n| PropertyDeclaration::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_secondary_constructor(&self) -> Option<SecondaryConstructor> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "secondary_constructor")
            .map(|n| SecondaryConstructor::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_secondary_constructor(&self) -> Vec<SecondaryConstructor> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "secondary_constructor")
            .map(|n| SecondaryConstructor::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_setter(&self) -> Option<Setter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "setter")
            .map(|n| Setter::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_setter(&self) -> Vec<Setter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "setter")
            .map(|n| Setter::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_alias(&self) -> Option<TypeAlias> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_alias")
            .map(|n| TypeAlias::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_alias(&self) -> Vec<TypeAlias> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_alias")
            .map(|n| TypeAlias::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for EnumClassBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref EnumEntryId: u16 = crate::LANGUAGE.id_for_node_kind("enum_entry", true);
}
pub struct EnumEntry<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> EnumEntry<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_class_body(&self) -> Option<ClassBody> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "class_body")
            .map(|n| ClassBody::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_class_body(&self) -> Vec<ClassBody> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "class_body")
            .map(|n| ClassBody::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_modifiers(&self) -> Option<Modifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "modifiers")
            .map(|n| Modifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_modifiers(&self) -> Vec<Modifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "modifiers")
            .map(|n| Modifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_value_arguments(&self) -> Option<ValueArguments> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "value_arguments")
            .map(|n| ValueArguments::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_value_arguments(&self) -> Vec<ValueArguments> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "value_arguments")
            .map(|n| ValueArguments::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for EnumEntry<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref EqualityExpressionId: u16 = crate::LANGUAGE.id_for_node_kind("equality_expression", true);
}
pub struct EqualityExpression<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> EqualityExpression<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for EqualityExpression<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref ExplicitDelegationId: u16 = crate::LANGUAGE.id_for_node_kind("explicit_delegation", true);
}
pub struct ExplicitDelegation<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> ExplicitDelegation<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_function_type(&self) -> Option<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_type")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_type(&self) -> Vec<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_type")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_user_type(&self) -> Option<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "user_type")
            .map(|n| UserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_user_type(&self) -> Vec<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "user_type")
            .map(|n| UserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for ExplicitDelegation<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref FileAnnotationId: u16 = crate::LANGUAGE.id_for_node_kind("file_annotation", true);
}
pub struct FileAnnotation<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> FileAnnotation<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_constructor_invocation(&self) -> Option<ConstructorInvocation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "constructor_invocation")
            .map(|n| ConstructorInvocation::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_constructor_invocation(&self) -> Vec<ConstructorInvocation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "constructor_invocation")
            .map(|n| ConstructorInvocation::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_user_type(&self) -> Option<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "user_type")
            .map(|n| UserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_user_type(&self) -> Vec<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "user_type")
            .map(|n| UserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for FileAnnotation<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref FinallyBlockId: u16 = crate::LANGUAGE.id_for_node_kind("finally_block", true);
}
pub struct FinallyBlock<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> FinallyBlock<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_statements(&self) -> Option<Statements> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "statements")
            .map(|n| Statements::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_statements(&self) -> Vec<Statements> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "statements")
            .map(|n| Statements::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for FinallyBlock<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref ForStatementId: u16 = crate::LANGUAGE.id_for_node_kind("for_statement", true);
}
pub struct ForStatement<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> ForStatement<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_annotation(&self) -> Option<Annotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "annotation")
            .map(|n| Annotation::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_annotation(&self) -> Vec<Annotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "annotation")
            .map(|n| Annotation::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_control_structure_body(&self) -> Option<ControlStructureBody> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "control_structure_body")
            .map(|n| ControlStructureBody::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_control_structure_body(&self) -> Vec<ControlStructureBody> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "control_structure_body")
            .map(|n| ControlStructureBody::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multi_variable_declaration(&self) -> Option<MultiVariableDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multi_variable_declaration")
            .map(|n| MultiVariableDeclaration::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multi_variable_declaration(&self) -> Vec<MultiVariableDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multi_variable_declaration")
            .map(|n| MultiVariableDeclaration::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_variable_declaration(&self) -> Option<VariableDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "variable_declaration")
            .map(|n| VariableDeclaration::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_variable_declaration(&self) -> Vec<VariableDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "variable_declaration")
            .map(|n| VariableDeclaration::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for ForStatement<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref FunctionBodyId: u16 = crate::LANGUAGE.id_for_node_kind("function_body", true);
}
pub struct FunctionBody<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> FunctionBody<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_statements(&self) -> Option<Statements> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "statements")
            .map(|n| Statements::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_statements(&self) -> Vec<Statements> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "statements")
            .map(|n| Statements::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for FunctionBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref FunctionDeclarationId: u16 = crate::LANGUAGE.id_for_node_kind("function_declaration", true);
}
pub struct FunctionDeclaration<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> FunctionDeclaration<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_function_body(&self) -> Option<FunctionBody> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_body")
            .map(|n| FunctionBody::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_body(&self) -> Vec<FunctionBody> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_body")
            .map(|n| FunctionBody::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_function_type(&self) -> Option<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_type")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_type(&self) -> Vec<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_type")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_function_value_parameters(&self) -> Option<FunctionValueParameters> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_value_parameters")
            .map(|n| FunctionValueParameters::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_value_parameters(&self) -> Vec<FunctionValueParameters> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_value_parameters")
            .map(|n| FunctionValueParameters::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_modifiers(&self) -> Option<Modifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "modifiers")
            .map(|n| Modifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_modifiers(&self) -> Vec<Modifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "modifiers")
            .map(|n| Modifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_not_nullable_type(&self) -> Option<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "not_nullable_type")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_not_nullable_type(&self) -> Vec<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "not_nullable_type")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_nullable_type(&self) -> Option<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "nullable_type")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_nullable_type(&self) -> Vec<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "nullable_type")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_type(&self) -> Option<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_type")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_type(&self) -> Vec<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_type")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_constraints(&self) -> Option<TypeConstraints> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_constraints")
            .map(|n| TypeConstraints::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_constraints(&self) -> Vec<TypeConstraints> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_constraints")
            .map(|n| TypeConstraints::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_modifiers(&self) -> Option<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_modifiers")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_modifiers(&self) -> Vec<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_modifiers")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_parameters(&self) -> Option<TypeParameters> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_parameters")
            .map(|n| TypeParameters::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_parameters(&self) -> Vec<TypeParameters> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_parameters")
            .map(|n| TypeParameters::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_user_type(&self) -> Option<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "user_type")
            .map(|n| UserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_user_type(&self) -> Vec<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "user_type")
            .map(|n| UserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for FunctionDeclaration<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref FunctionModifierId: u16 = crate::LANGUAGE.id_for_node_kind("function_modifier", true);
}
pub struct FunctionModifier<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> FunctionModifier<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }}

impl<'a> std::fmt::Debug for FunctionModifier<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref FunctionTypeId: u16 = crate::LANGUAGE.id_for_node_kind("function_type", true);
}
pub struct FunctionType<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> FunctionType<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_function_type(&self) -> Option<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_type")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_type(&self) -> Vec<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_type")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_function_type_parameters(&self) -> Option<FunctionTypeParameters> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_type_parameters")
            .map(|n| FunctionTypeParameters::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_type_parameters(&self) -> Vec<FunctionTypeParameters> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_type_parameters")
            .map(|n| FunctionTypeParameters::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_not_nullable_type(&self) -> Option<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "not_nullable_type")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_not_nullable_type(&self) -> Vec<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "not_nullable_type")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_nullable_type(&self) -> Option<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "nullable_type")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_nullable_type(&self) -> Vec<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "nullable_type")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_type(&self) -> Option<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_type")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_type(&self) -> Vec<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_type")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_arguments(&self) -> Option<TypeArguments> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_arguments")
            .map(|n| TypeArguments::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_arguments(&self) -> Vec<TypeArguments> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_arguments")
            .map(|n| TypeArguments::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_identifier(&self) -> Option<TypeIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_identifier(&self) -> Vec<TypeIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_modifiers(&self) -> Option<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_modifiers")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_modifiers(&self) -> Vec<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_modifiers")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_user_type(&self) -> Option<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "user_type")
            .map(|n| UserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_user_type(&self) -> Vec<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "user_type")
            .map(|n| UserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for FunctionType<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref FunctionTypeParametersId: u16 = crate::LANGUAGE.id_for_node_kind("function_type_parameters", true);
}
pub struct FunctionTypeParameters<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> FunctionTypeParameters<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_function_type(&self) -> Option<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_type")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_type(&self) -> Vec<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_type")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_not_nullable_type(&self) -> Option<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "not_nullable_type")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_not_nullable_type(&self) -> Vec<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "not_nullable_type")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_nullable_type(&self) -> Option<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "nullable_type")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_nullable_type(&self) -> Vec<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "nullable_type")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parameter(&self) -> Option<Parameter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parameter")
            .map(|n| Parameter::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parameter(&self) -> Vec<Parameter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parameter")
            .map(|n| Parameter::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_type(&self) -> Option<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_type")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_type(&self) -> Vec<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_type")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_modifiers(&self) -> Option<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_modifiers")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_modifiers(&self) -> Vec<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_modifiers")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_user_type(&self) -> Option<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "user_type")
            .map(|n| UserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_user_type(&self) -> Vec<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "user_type")
            .map(|n| UserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for FunctionTypeParameters<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref FunctionValueParametersId: u16 = crate::LANGUAGE.id_for_node_kind("function_value_parameters", true);
}
pub struct FunctionValueParameters<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> FunctionValueParameters<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parameter(&self) -> Option<Parameter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parameter")
            .map(|n| Parameter::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parameter(&self) -> Vec<Parameter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parameter")
            .map(|n| Parameter::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parameter_modifiers(&self) -> Option<ParameterModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parameter_modifiers")
            .map(|n| ParameterModifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parameter_modifiers(&self) -> Vec<ParameterModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parameter_modifiers")
            .map(|n| ParameterModifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for FunctionValueParameters<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref GetterId: u16 = crate::LANGUAGE.id_for_node_kind("getter", true);
}
pub struct Getter<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> Getter<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_function_body(&self) -> Option<FunctionBody> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_body")
            .map(|n| FunctionBody::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_body(&self) -> Vec<FunctionBody> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_body")
            .map(|n| FunctionBody::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_function_type(&self) -> Option<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_type")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_type(&self) -> Vec<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_type")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_modifiers(&self) -> Option<Modifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "modifiers")
            .map(|n| Modifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_modifiers(&self) -> Vec<Modifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "modifiers")
            .map(|n| Modifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_not_nullable_type(&self) -> Option<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "not_nullable_type")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_not_nullable_type(&self) -> Vec<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "not_nullable_type")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_nullable_type(&self) -> Option<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "nullable_type")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_nullable_type(&self) -> Vec<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "nullable_type")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_type(&self) -> Option<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_type")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_type(&self) -> Vec<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_type")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_modifiers(&self) -> Option<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_modifiers")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_modifiers(&self) -> Vec<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_modifiers")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_user_type(&self) -> Option<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "user_type")
            .map(|n| UserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_user_type(&self) -> Vec<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "user_type")
            .map(|n| UserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for Getter<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref IdentifierId: u16 = crate::LANGUAGE.id_for_node_kind("identifier", true);
}
pub struct Identifier<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> Identifier<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for Identifier<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref IfExpressionId: u16 = crate::LANGUAGE.id_for_node_kind("if_expression", true);
}
pub struct IfExpression<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> IfExpression<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }}

impl<'a> std::fmt::Debug for IfExpression<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref ImportAliasId: u16 = crate::LANGUAGE.id_for_node_kind("import_alias", true);
}
pub struct ImportAlias<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> ImportAlias<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_type_identifier(&self) -> Option<TypeIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_identifier(&self) -> Vec<TypeIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for ImportAlias<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref ImportHeaderId: u16 = crate::LANGUAGE.id_for_node_kind("import_header", true);
}
pub struct ImportHeader<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> ImportHeader<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_identifier(&self) -> Option<Identifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "identifier")
            .map(|n| Identifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_identifier(&self) -> Vec<Identifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "identifier")
            .map(|n| Identifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_import_alias(&self) -> Option<ImportAlias> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "import_alias")
            .map(|n| ImportAlias::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_import_alias(&self) -> Vec<ImportAlias> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "import_alias")
            .map(|n| ImportAlias::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_wildcard_import(&self) -> Option<WildcardImport> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "wildcard_import")
            .map(|n| WildcardImport::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_wildcard_import(&self) -> Vec<WildcardImport> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "wildcard_import")
            .map(|n| WildcardImport::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for ImportHeader<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref ImportListId: u16 = crate::LANGUAGE.id_for_node_kind("import_list", true);
}
pub struct ImportList<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> ImportList<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_import_header(&self) -> Option<ImportHeader> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "import_header")
            .map(|n| ImportHeader::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_import_header(&self) -> Vec<ImportHeader> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "import_header")
            .map(|n| ImportHeader::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for ImportList<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref IndexingExpressionId: u16 = crate::LANGUAGE.id_for_node_kind("indexing_expression", true);
}
pub struct IndexingExpression<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> IndexingExpression<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_suffix(&self) -> Option<IndexingSuffix> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_suffix")
            .map(|n| IndexingSuffix::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_suffix(&self) -> Vec<IndexingSuffix> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_suffix")
            .map(|n| IndexingSuffix::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for IndexingExpression<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref IndexingSuffixId: u16 = crate::LANGUAGE.id_for_node_kind("indexing_suffix", true);
}
pub struct IndexingSuffix<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> IndexingSuffix<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for IndexingSuffix<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref InfixExpressionId: u16 = crate::LANGUAGE.id_for_node_kind("infix_expression", true);
}
pub struct InfixExpression<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> InfixExpression<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for InfixExpression<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref InheritanceModifierId: u16 = crate::LANGUAGE.id_for_node_kind("inheritance_modifier", true);
}
pub struct InheritanceModifier<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> InheritanceModifier<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }}

impl<'a> std::fmt::Debug for InheritanceModifier<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref InterpolatedExpressionId: u16 = crate::LANGUAGE.id_for_node_kind("interpolated_expression", true);
}
pub struct InterpolatedExpression<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> InterpolatedExpression<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for InterpolatedExpression<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref InterpolatedIdentifierId: u16 = crate::LANGUAGE.id_for_node_kind("interpolated_identifier", true);
}
pub struct InterpolatedIdentifier<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> InterpolatedIdentifier<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }}

impl<'a> std::fmt::Debug for InterpolatedIdentifier<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref JumpExpressionId: u16 = crate::LANGUAGE.id_for_node_kind("jump_expression", true);
}
pub struct JumpExpression<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> JumpExpression<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_label(&self) -> Option<Label> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "label")
            .map(|n| Label::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_label(&self) -> Vec<Label> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "label")
            .map(|n| Label::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for JumpExpression<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref LabelId: u16 = crate::LANGUAGE.id_for_node_kind("label", true);
}
pub struct Label<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> Label<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }}

impl<'a> std::fmt::Debug for Label<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref LambdaLiteralId: u16 = crate::LANGUAGE.id_for_node_kind("lambda_literal", true);
}
pub struct LambdaLiteral<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> LambdaLiteral<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_lambda_parameters(&self) -> Option<LambdaParameters> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_parameters")
            .map(|n| LambdaParameters::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_parameters(&self) -> Vec<LambdaParameters> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_parameters")
            .map(|n| LambdaParameters::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_statements(&self) -> Option<Statements> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "statements")
            .map(|n| Statements::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_statements(&self) -> Vec<Statements> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "statements")
            .map(|n| Statements::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for LambdaLiteral<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref LambdaParametersId: u16 = crate::LANGUAGE.id_for_node_kind("lambda_parameters", true);
}
pub struct LambdaParameters<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> LambdaParameters<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_multi_variable_declaration(&self) -> Option<MultiVariableDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multi_variable_declaration")
            .map(|n| MultiVariableDeclaration::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multi_variable_declaration(&self) -> Vec<MultiVariableDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multi_variable_declaration")
            .map(|n| MultiVariableDeclaration::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_variable_declaration(&self) -> Option<VariableDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "variable_declaration")
            .map(|n| VariableDeclaration::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_variable_declaration(&self) -> Vec<VariableDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "variable_declaration")
            .map(|n| VariableDeclaration::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for LambdaParameters<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref LongLiteralId: u16 = crate::LANGUAGE.id_for_node_kind("long_literal", true);
}
pub struct LongLiteral<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> LongLiteral<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for LongLiteral<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref MemberModifierId: u16 = crate::LANGUAGE.id_for_node_kind("member_modifier", true);
}
pub struct MemberModifier<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> MemberModifier<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }}

impl<'a> std::fmt::Debug for MemberModifier<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref ModifiersId: u16 = crate::LANGUAGE.id_for_node_kind("modifiers", true);
}
pub struct Modifiers<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> Modifiers<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_annotation(&self) -> Option<Annotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "annotation")
            .map(|n| Annotation::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_annotation(&self) -> Vec<Annotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "annotation")
            .map(|n| Annotation::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_class_modifier(&self) -> Option<ClassModifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "class_modifier")
            .map(|n| ClassModifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_class_modifier(&self) -> Vec<ClassModifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "class_modifier")
            .map(|n| ClassModifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_function_modifier(&self) -> Option<FunctionModifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_modifier")
            .map(|n| FunctionModifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_modifier(&self) -> Vec<FunctionModifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_modifier")
            .map(|n| FunctionModifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_inheritance_modifier(&self) -> Option<InheritanceModifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "inheritance_modifier")
            .map(|n| InheritanceModifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_inheritance_modifier(&self) -> Vec<InheritanceModifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "inheritance_modifier")
            .map(|n| InheritanceModifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_member_modifier(&self) -> Option<MemberModifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "member_modifier")
            .map(|n| MemberModifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_member_modifier(&self) -> Vec<MemberModifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "member_modifier")
            .map(|n| MemberModifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parameter_modifier(&self) -> Option<ParameterModifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parameter_modifier")
            .map(|n| ParameterModifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parameter_modifier(&self) -> Vec<ParameterModifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parameter_modifier")
            .map(|n| ParameterModifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_platform_modifier(&self) -> Option<PlatformModifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "platform_modifier")
            .map(|n| PlatformModifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_platform_modifier(&self) -> Vec<PlatformModifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "platform_modifier")
            .map(|n| PlatformModifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_property_modifier(&self) -> Option<PropertyModifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "property_modifier")
            .map(|n| PropertyModifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_property_modifier(&self) -> Vec<PropertyModifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "property_modifier")
            .map(|n| PropertyModifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_visibility_modifier(&self) -> Option<VisibilityModifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "visibility_modifier")
            .map(|n| VisibilityModifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_visibility_modifier(&self) -> Vec<VisibilityModifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "visibility_modifier")
            .map(|n| VisibilityModifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for Modifiers<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref MultiVariableDeclarationId: u16 = crate::LANGUAGE.id_for_node_kind("multi_variable_declaration", true);
}
pub struct MultiVariableDeclaration<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> MultiVariableDeclaration<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_variable_declaration(&self) -> Option<VariableDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "variable_declaration")
            .map(|n| VariableDeclaration::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_variable_declaration(&self) -> Vec<VariableDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "variable_declaration")
            .map(|n| VariableDeclaration::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for MultiVariableDeclaration<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref MultiplicativeExpressionId: u16 = crate::LANGUAGE.id_for_node_kind("multiplicative_expression", true);
}
pub struct MultiplicativeExpression<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> MultiplicativeExpression<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for MultiplicativeExpression<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref NavigationExpressionId: u16 = crate::LANGUAGE.id_for_node_kind("navigation_expression", true);
}
pub struct NavigationExpression<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> NavigationExpression<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_suffix(&self) -> Option<NavigationSuffix> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_suffix")
            .map(|n| NavigationSuffix::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_suffix(&self) -> Vec<NavigationSuffix> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_suffix")
            .map(|n| NavigationSuffix::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for NavigationExpression<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref NavigationSuffixId: u16 = crate::LANGUAGE.id_for_node_kind("navigation_suffix", true);
}
pub struct NavigationSuffix<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> NavigationSuffix<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for NavigationSuffix<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref NotNullableTypeId: u16 = crate::LANGUAGE.id_for_node_kind("not_nullable_type", true);
}
pub struct NotNullableType<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> NotNullableType<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_parenthesized_user_type(&self) -> Option<ParenthesizedUserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_user_type")
            .map(|n| ParenthesizedUserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_user_type(&self) -> Vec<ParenthesizedUserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_user_type")
            .map(|n| ParenthesizedUserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_modifiers(&self) -> Option<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_modifiers")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_modifiers(&self) -> Vec<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_modifiers")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_user_type(&self) -> Option<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "user_type")
            .map(|n| UserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_user_type(&self) -> Vec<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "user_type")
            .map(|n| UserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for NotNullableType<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref NullableTypeId: u16 = crate::LANGUAGE.id_for_node_kind("nullable_type", true);
}
pub struct NullableType<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> NullableType<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_parenthesized_type(&self) -> Option<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_type")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_type(&self) -> Vec<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_type")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_user_type(&self) -> Option<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "user_type")
            .map(|n| UserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_user_type(&self) -> Vec<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "user_type")
            .map(|n| UserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for NullableType<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref ObjectDeclarationId: u16 = crate::LANGUAGE.id_for_node_kind("object_declaration", true);
}
pub struct ObjectDeclaration<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> ObjectDeclaration<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_class_body(&self) -> Option<ClassBody> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "class_body")
            .map(|n| ClassBody::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_class_body(&self) -> Vec<ClassBody> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "class_body")
            .map(|n| ClassBody::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_delegation_specifier(&self) -> Option<DelegationSpecifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "delegation_specifier")
            .map(|n| DelegationSpecifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_delegation_specifier(&self) -> Vec<DelegationSpecifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "delegation_specifier")
            .map(|n| DelegationSpecifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_modifiers(&self) -> Option<Modifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "modifiers")
            .map(|n| Modifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_modifiers(&self) -> Vec<Modifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "modifiers")
            .map(|n| Modifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_identifier(&self) -> Option<TypeIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_identifier(&self) -> Vec<TypeIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for ObjectDeclaration<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref ObjectLiteralId: u16 = crate::LANGUAGE.id_for_node_kind("object_literal", true);
}
pub struct ObjectLiteral<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> ObjectLiteral<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_class_body(&self) -> Option<ClassBody> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "class_body")
            .map(|n| ClassBody::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_class_body(&self) -> Vec<ClassBody> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "class_body")
            .map(|n| ClassBody::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_delegation_specifier(&self) -> Option<DelegationSpecifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "delegation_specifier")
            .map(|n| DelegationSpecifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_delegation_specifier(&self) -> Vec<DelegationSpecifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "delegation_specifier")
            .map(|n| DelegationSpecifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for ObjectLiteral<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref PackageHeaderId: u16 = crate::LANGUAGE.id_for_node_kind("package_header", true);
}
pub struct PackageHeader<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> PackageHeader<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_identifier(&self) -> Option<Identifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "identifier")
            .map(|n| Identifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_identifier(&self) -> Vec<Identifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "identifier")
            .map(|n| Identifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for PackageHeader<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref ParameterId: u16 = crate::LANGUAGE.id_for_node_kind("parameter", true);
}
pub struct Parameter<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> Parameter<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_function_type(&self) -> Option<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_type")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_type(&self) -> Vec<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_type")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_not_nullable_type(&self) -> Option<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "not_nullable_type")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_not_nullable_type(&self) -> Vec<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "not_nullable_type")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_nullable_type(&self) -> Option<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "nullable_type")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_nullable_type(&self) -> Vec<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "nullable_type")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_type(&self) -> Option<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_type")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_type(&self) -> Vec<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_type")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_modifiers(&self) -> Option<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_modifiers")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_modifiers(&self) -> Vec<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_modifiers")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_user_type(&self) -> Option<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "user_type")
            .map(|n| UserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_user_type(&self) -> Vec<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "user_type")
            .map(|n| UserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for Parameter<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref ParameterModifierId: u16 = crate::LANGUAGE.id_for_node_kind("parameter_modifier", true);
}
pub struct ParameterModifier<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> ParameterModifier<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }}

impl<'a> std::fmt::Debug for ParameterModifier<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref ParameterModifiersId: u16 = crate::LANGUAGE.id_for_node_kind("parameter_modifiers", true);
}
pub struct ParameterModifiers<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> ParameterModifiers<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_annotation(&self) -> Option<Annotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "annotation")
            .map(|n| Annotation::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_annotation(&self) -> Vec<Annotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "annotation")
            .map(|n| Annotation::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parameter_modifier(&self) -> Option<ParameterModifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parameter_modifier")
            .map(|n| ParameterModifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parameter_modifier(&self) -> Vec<ParameterModifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parameter_modifier")
            .map(|n| ParameterModifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for ParameterModifiers<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref ParameterWithOptionalTypeId: u16 = crate::LANGUAGE.id_for_node_kind("parameter_with_optional_type", true);
}
pub struct ParameterWithOptionalType<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> ParameterWithOptionalType<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_function_type(&self) -> Option<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_type")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_type(&self) -> Vec<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_type")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_not_nullable_type(&self) -> Option<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "not_nullable_type")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_not_nullable_type(&self) -> Vec<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "not_nullable_type")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_nullable_type(&self) -> Option<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "nullable_type")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_nullable_type(&self) -> Vec<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "nullable_type")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parameter_modifiers(&self) -> Option<ParameterModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parameter_modifiers")
            .map(|n| ParameterModifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parameter_modifiers(&self) -> Vec<ParameterModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parameter_modifiers")
            .map(|n| ParameterModifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_type(&self) -> Option<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_type")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_type(&self) -> Vec<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_type")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_modifiers(&self) -> Option<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_modifiers")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_modifiers(&self) -> Vec<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_modifiers")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_user_type(&self) -> Option<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "user_type")
            .map(|n| UserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_user_type(&self) -> Vec<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "user_type")
            .map(|n| UserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for ParameterWithOptionalType<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref ParenthesizedExpressionId: u16 = crate::LANGUAGE.id_for_node_kind("parenthesized_expression", true);
}
pub struct ParenthesizedExpression<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> ParenthesizedExpression<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for ParenthesizedExpression<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref ParenthesizedTypeId: u16 = crate::LANGUAGE.id_for_node_kind("parenthesized_type", true);
}
pub struct ParenthesizedType<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> ParenthesizedType<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_function_type(&self) -> Option<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_type")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_type(&self) -> Vec<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_type")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_not_nullable_type(&self) -> Option<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "not_nullable_type")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_not_nullable_type(&self) -> Vec<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "not_nullable_type")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_nullable_type(&self) -> Option<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "nullable_type")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_nullable_type(&self) -> Vec<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "nullable_type")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_type(&self) -> Option<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_type")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_type(&self) -> Vec<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_type")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_modifiers(&self) -> Option<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_modifiers")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_modifiers(&self) -> Vec<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_modifiers")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_user_type(&self) -> Option<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "user_type")
            .map(|n| UserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_user_type(&self) -> Vec<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "user_type")
            .map(|n| UserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for ParenthesizedType<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref ParenthesizedUserTypeId: u16 = crate::LANGUAGE.id_for_node_kind("parenthesized_user_type", true);
}
pub struct ParenthesizedUserType<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> ParenthesizedUserType<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_parenthesized_user_type(&self) -> Option<ParenthesizedUserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_user_type")
            .map(|n| ParenthesizedUserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_user_type(&self) -> Vec<ParenthesizedUserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_user_type")
            .map(|n| ParenthesizedUserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_user_type(&self) -> Option<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "user_type")
            .map(|n| UserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_user_type(&self) -> Vec<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "user_type")
            .map(|n| UserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for ParenthesizedUserType<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref PlatformModifierId: u16 = crate::LANGUAGE.id_for_node_kind("platform_modifier", true);
}
pub struct PlatformModifier<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> PlatformModifier<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }}

impl<'a> std::fmt::Debug for PlatformModifier<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref PostfixExpressionId: u16 = crate::LANGUAGE.id_for_node_kind("postfix_expression", true);
}
pub struct PostfixExpression<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> PostfixExpression<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for PostfixExpression<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref PrefixExpressionId: u16 = crate::LANGUAGE.id_for_node_kind("prefix_expression", true);
}
pub struct PrefixExpression<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> PrefixExpression<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_annotation(&self) -> Option<Annotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "annotation")
            .map(|n| Annotation::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_annotation(&self) -> Vec<Annotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "annotation")
            .map(|n| Annotation::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_label(&self) -> Option<Label> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "label")
            .map(|n| Label::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_label(&self) -> Vec<Label> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "label")
            .map(|n| Label::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for PrefixExpression<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref PrimaryConstructorId: u16 = crate::LANGUAGE.id_for_node_kind("primary_constructor", true);
}
pub struct PrimaryConstructor<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> PrimaryConstructor<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_class_parameter(&self) -> Option<ClassParameter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "class_parameter")
            .map(|n| ClassParameter::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_class_parameter(&self) -> Vec<ClassParameter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "class_parameter")
            .map(|n| ClassParameter::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_modifiers(&self) -> Option<Modifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "modifiers")
            .map(|n| Modifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_modifiers(&self) -> Vec<Modifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "modifiers")
            .map(|n| Modifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for PrimaryConstructor<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref PropertyDeclarationId: u16 = crate::LANGUAGE.id_for_node_kind("property_declaration", true);
}
pub struct PropertyDeclaration<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> PropertyDeclaration<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_binding_pattern_kind(&self) -> Option<BindingPatternKind> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "binding_pattern_kind")
            .map(|n| BindingPatternKind::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_binding_pattern_kind(&self) -> Vec<BindingPatternKind> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "binding_pattern_kind")
            .map(|n| BindingPatternKind::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_getter(&self) -> Option<Getter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "getter")
            .map(|n| Getter::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_getter(&self) -> Vec<Getter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "getter")
            .map(|n| Getter::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_modifiers(&self) -> Option<Modifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "modifiers")
            .map(|n| Modifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_modifiers(&self) -> Vec<Modifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "modifiers")
            .map(|n| Modifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multi_variable_declaration(&self) -> Option<MultiVariableDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multi_variable_declaration")
            .map(|n| MultiVariableDeclaration::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multi_variable_declaration(&self) -> Vec<MultiVariableDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multi_variable_declaration")
            .map(|n| MultiVariableDeclaration::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_nullable_type(&self) -> Option<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "nullable_type")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_nullable_type(&self) -> Vec<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "nullable_type")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_type(&self) -> Option<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_type")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_type(&self) -> Vec<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_type")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_property_delegate(&self) -> Option<PropertyDelegate> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "property_delegate")
            .map(|n| PropertyDelegate::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_property_delegate(&self) -> Vec<PropertyDelegate> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "property_delegate")
            .map(|n| PropertyDelegate::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_setter(&self) -> Option<Setter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "setter")
            .map(|n| Setter::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_setter(&self) -> Vec<Setter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "setter")
            .map(|n| Setter::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_constraints(&self) -> Option<TypeConstraints> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_constraints")
            .map(|n| TypeConstraints::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_constraints(&self) -> Vec<TypeConstraints> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_constraints")
            .map(|n| TypeConstraints::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_modifiers(&self) -> Option<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_modifiers")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_modifiers(&self) -> Vec<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_modifiers")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_parameters(&self) -> Option<TypeParameters> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_parameters")
            .map(|n| TypeParameters::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_parameters(&self) -> Vec<TypeParameters> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_parameters")
            .map(|n| TypeParameters::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_user_type(&self) -> Option<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "user_type")
            .map(|n| UserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_user_type(&self) -> Vec<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "user_type")
            .map(|n| UserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_variable_declaration(&self) -> Option<VariableDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "variable_declaration")
            .map(|n| VariableDeclaration::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_variable_declaration(&self) -> Vec<VariableDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "variable_declaration")
            .map(|n| VariableDeclaration::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for PropertyDeclaration<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref PropertyDelegateId: u16 = crate::LANGUAGE.id_for_node_kind("property_delegate", true);
}
pub struct PropertyDelegate<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> PropertyDelegate<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for PropertyDelegate<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref RangeExpressionId: u16 = crate::LANGUAGE.id_for_node_kind("range_expression", true);
}
pub struct RangeExpression<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> RangeExpression<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for RangeExpression<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref RangeTestId: u16 = crate::LANGUAGE.id_for_node_kind("range_test", true);
}
pub struct RangeTest<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> RangeTest<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for RangeTest<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref SecondaryConstructorId: u16 = crate::LANGUAGE.id_for_node_kind("secondary_constructor", true);
}
pub struct SecondaryConstructor<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> SecondaryConstructor<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_constructor_delegation_call(&self) -> Option<ConstructorDelegationCall> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "constructor_delegation_call")
            .map(|n| ConstructorDelegationCall::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_constructor_delegation_call(&self) -> Vec<ConstructorDelegationCall> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "constructor_delegation_call")
            .map(|n| ConstructorDelegationCall::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_function_value_parameters(&self) -> Option<FunctionValueParameters> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_value_parameters")
            .map(|n| FunctionValueParameters::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_value_parameters(&self) -> Vec<FunctionValueParameters> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_value_parameters")
            .map(|n| FunctionValueParameters::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_modifiers(&self) -> Option<Modifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "modifiers")
            .map(|n| Modifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_modifiers(&self) -> Vec<Modifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "modifiers")
            .map(|n| Modifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_statements(&self) -> Option<Statements> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "statements")
            .map(|n| Statements::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_statements(&self) -> Vec<Statements> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "statements")
            .map(|n| Statements::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for SecondaryConstructor<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref SetterId: u16 = crate::LANGUAGE.id_for_node_kind("setter", true);
}
pub struct Setter<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> Setter<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_function_body(&self) -> Option<FunctionBody> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_body")
            .map(|n| FunctionBody::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_body(&self) -> Vec<FunctionBody> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_body")
            .map(|n| FunctionBody::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_function_type(&self) -> Option<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_type")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_type(&self) -> Vec<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_type")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_modifiers(&self) -> Option<Modifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "modifiers")
            .map(|n| Modifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_modifiers(&self) -> Vec<Modifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "modifiers")
            .map(|n| Modifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_not_nullable_type(&self) -> Option<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "not_nullable_type")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_not_nullable_type(&self) -> Vec<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "not_nullable_type")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_nullable_type(&self) -> Option<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "nullable_type")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_nullable_type(&self) -> Vec<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "nullable_type")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parameter_with_optional_type(&self) -> Option<ParameterWithOptionalType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parameter_with_optional_type")
            .map(|n| ParameterWithOptionalType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parameter_with_optional_type(&self) -> Vec<ParameterWithOptionalType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parameter_with_optional_type")
            .map(|n| ParameterWithOptionalType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_type(&self) -> Option<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_type")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_type(&self) -> Vec<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_type")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_modifiers(&self) -> Option<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_modifiers")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_modifiers(&self) -> Vec<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_modifiers")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_user_type(&self) -> Option<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "user_type")
            .map(|n| UserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_user_type(&self) -> Vec<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "user_type")
            .map(|n| UserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for Setter<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref ShebangLineId: u16 = crate::LANGUAGE.id_for_node_kind("shebang_line", true);
}
pub struct ShebangLine<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> ShebangLine<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }}

impl<'a> std::fmt::Debug for ShebangLine<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref SimpleIdentifierId: u16 = crate::LANGUAGE.id_for_node_kind("simple_identifier", true);
}
pub struct SimpleIdentifier<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> SimpleIdentifier<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }}

impl<'a> std::fmt::Debug for SimpleIdentifier<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref SourceFileId: u16 = crate::LANGUAGE.id_for_node_kind("source_file", true);
}
pub struct SourceFile<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> SourceFile<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_annotation(&self) -> Option<Annotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "annotation")
            .map(|n| Annotation::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_annotation(&self) -> Vec<Annotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "annotation")
            .map(|n| Annotation::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_assignment(&self) -> Option<Assignment> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "assignment")
            .map(|n| Assignment::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_assignment(&self) -> Vec<Assignment> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "assignment")
            .map(|n| Assignment::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_class_declaration(&self) -> Option<ClassDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "class_declaration")
            .map(|n| ClassDeclaration::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_class_declaration(&self) -> Vec<ClassDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "class_declaration")
            .map(|n| ClassDeclaration::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_do_while_statement(&self) -> Option<DoWhileStatement> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "do_while_statement")
            .map(|n| DoWhileStatement::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_do_while_statement(&self) -> Vec<DoWhileStatement> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "do_while_statement")
            .map(|n| DoWhileStatement::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_file_annotation(&self) -> Option<FileAnnotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "file_annotation")
            .map(|n| FileAnnotation::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_file_annotation(&self) -> Vec<FileAnnotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "file_annotation")
            .map(|n| FileAnnotation::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_for_statement(&self) -> Option<ForStatement> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "for_statement")
            .map(|n| ForStatement::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_for_statement(&self) -> Vec<ForStatement> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "for_statement")
            .map(|n| ForStatement::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_function_declaration(&self) -> Option<FunctionDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_declaration")
            .map(|n| FunctionDeclaration::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_declaration(&self) -> Vec<FunctionDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_declaration")
            .map(|n| FunctionDeclaration::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_getter(&self) -> Option<Getter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "getter")
            .map(|n| Getter::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_getter(&self) -> Vec<Getter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "getter")
            .map(|n| Getter::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_import_list(&self) -> Option<ImportList> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "import_list")
            .map(|n| ImportList::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_import_list(&self) -> Vec<ImportList> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "import_list")
            .map(|n| ImportList::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_label(&self) -> Option<Label> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "label")
            .map(|n| Label::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_label(&self) -> Vec<Label> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "label")
            .map(|n| Label::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_declaration(&self) -> Option<ObjectDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_declaration")
            .map(|n| ObjectDeclaration::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_declaration(&self) -> Vec<ObjectDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_declaration")
            .map(|n| ObjectDeclaration::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_package_header(&self) -> Option<PackageHeader> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "package_header")
            .map(|n| PackageHeader::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_package_header(&self) -> Vec<PackageHeader> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "package_header")
            .map(|n| PackageHeader::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_property_declaration(&self) -> Option<PropertyDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "property_declaration")
            .map(|n| PropertyDeclaration::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_property_declaration(&self) -> Vec<PropertyDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "property_declaration")
            .map(|n| PropertyDeclaration::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_setter(&self) -> Option<Setter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "setter")
            .map(|n| Setter::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_setter(&self) -> Vec<Setter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "setter")
            .map(|n| Setter::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_shebang_line(&self) -> Option<ShebangLine> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "shebang_line")
            .map(|n| ShebangLine::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_shebang_line(&self) -> Vec<ShebangLine> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "shebang_line")
            .map(|n| ShebangLine::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_alias(&self) -> Option<TypeAlias> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_alias")
            .map(|n| TypeAlias::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_alias(&self) -> Vec<TypeAlias> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_alias")
            .map(|n| TypeAlias::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_while_statement(&self) -> Option<WhileStatement> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "while_statement")
            .map(|n| WhileStatement::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_while_statement(&self) -> Vec<WhileStatement> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "while_statement")
            .map(|n| WhileStatement::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for SourceFile<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref SpreadExpressionId: u16 = crate::LANGUAGE.id_for_node_kind("spread_expression", true);
}
pub struct SpreadExpression<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> SpreadExpression<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for SpreadExpression<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref StatementsId: u16 = crate::LANGUAGE.id_for_node_kind("statements", true);
}
pub struct Statements<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> Statements<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_annotation(&self) -> Option<Annotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "annotation")
            .map(|n| Annotation::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_annotation(&self) -> Vec<Annotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "annotation")
            .map(|n| Annotation::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_assignment(&self) -> Option<Assignment> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "assignment")
            .map(|n| Assignment::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_assignment(&self) -> Vec<Assignment> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "assignment")
            .map(|n| Assignment::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_class_declaration(&self) -> Option<ClassDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "class_declaration")
            .map(|n| ClassDeclaration::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_class_declaration(&self) -> Vec<ClassDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "class_declaration")
            .map(|n| ClassDeclaration::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_do_while_statement(&self) -> Option<DoWhileStatement> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "do_while_statement")
            .map(|n| DoWhileStatement::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_do_while_statement(&self) -> Vec<DoWhileStatement> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "do_while_statement")
            .map(|n| DoWhileStatement::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_for_statement(&self) -> Option<ForStatement> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "for_statement")
            .map(|n| ForStatement::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_for_statement(&self) -> Vec<ForStatement> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "for_statement")
            .map(|n| ForStatement::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_function_declaration(&self) -> Option<FunctionDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_declaration")
            .map(|n| FunctionDeclaration::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_declaration(&self) -> Vec<FunctionDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_declaration")
            .map(|n| FunctionDeclaration::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_getter(&self) -> Option<Getter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "getter")
            .map(|n| Getter::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_getter(&self) -> Vec<Getter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "getter")
            .map(|n| Getter::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_label(&self) -> Option<Label> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "label")
            .map(|n| Label::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_label(&self) -> Vec<Label> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "label")
            .map(|n| Label::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_declaration(&self) -> Option<ObjectDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_declaration")
            .map(|n| ObjectDeclaration::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_declaration(&self) -> Vec<ObjectDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_declaration")
            .map(|n| ObjectDeclaration::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_property_declaration(&self) -> Option<PropertyDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "property_declaration")
            .map(|n| PropertyDeclaration::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_property_declaration(&self) -> Vec<PropertyDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "property_declaration")
            .map(|n| PropertyDeclaration::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_setter(&self) -> Option<Setter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "setter")
            .map(|n| Setter::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_setter(&self) -> Vec<Setter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "setter")
            .map(|n| Setter::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_alias(&self) -> Option<TypeAlias> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_alias")
            .map(|n| TypeAlias::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_alias(&self) -> Vec<TypeAlias> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_alias")
            .map(|n| TypeAlias::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_while_statement(&self) -> Option<WhileStatement> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "while_statement")
            .map(|n| WhileStatement::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_while_statement(&self) -> Vec<WhileStatement> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "while_statement")
            .map(|n| WhileStatement::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for Statements<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref StringLiteralId: u16 = crate::LANGUAGE.id_for_node_kind("string_literal", true);
}
pub struct StringLiteral<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> StringLiteral<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_interpolated_expression(&self) -> Option<InterpolatedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "interpolated_expression")
            .map(|n| InterpolatedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_interpolated_expression(&self) -> Vec<InterpolatedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "interpolated_expression")
            .map(|n| InterpolatedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_interpolated_identifier(&self) -> Option<InterpolatedIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "interpolated_identifier")
            .map(|n| InterpolatedIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_interpolated_identifier(&self) -> Vec<InterpolatedIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "interpolated_identifier")
            .map(|n| InterpolatedIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_content(&self) -> Option<StringContent> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_content")
            .map(|n| StringContent::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_content(&self) -> Vec<StringContent> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_content")
            .map(|n| StringContent::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for StringLiteral<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref SuperExpressionId: u16 = crate::LANGUAGE.id_for_node_kind("super_expression", true);
}
pub struct SuperExpression<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> SuperExpression<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_function_type(&self) -> Option<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_type")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_type(&self) -> Vec<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_type")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_not_nullable_type(&self) -> Option<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "not_nullable_type")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_not_nullable_type(&self) -> Vec<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "not_nullable_type")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_nullable_type(&self) -> Option<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "nullable_type")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_nullable_type(&self) -> Vec<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "nullable_type")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_type(&self) -> Option<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_type")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_type(&self) -> Vec<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_type")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_identifier(&self) -> Option<TypeIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_identifier(&self) -> Vec<TypeIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_modifiers(&self) -> Option<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_modifiers")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_modifiers(&self) -> Vec<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_modifiers")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_user_type(&self) -> Option<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "user_type")
            .map(|n| UserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_user_type(&self) -> Vec<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "user_type")
            .map(|n| UserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for SuperExpression<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref ThisExpressionId: u16 = crate::LANGUAGE.id_for_node_kind("this_expression", true);
}
pub struct ThisExpression<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> ThisExpression<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_type_identifier(&self) -> Option<TypeIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_identifier(&self) -> Vec<TypeIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for ThisExpression<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref TryExpressionId: u16 = crate::LANGUAGE.id_for_node_kind("try_expression", true);
}
pub struct TryExpression<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> TryExpression<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_catch_block(&self) -> Option<CatchBlock> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "catch_block")
            .map(|n| CatchBlock::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_catch_block(&self) -> Vec<CatchBlock> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "catch_block")
            .map(|n| CatchBlock::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_finally_block(&self) -> Option<FinallyBlock> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "finally_block")
            .map(|n| FinallyBlock::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_finally_block(&self) -> Vec<FinallyBlock> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "finally_block")
            .map(|n| FinallyBlock::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_statements(&self) -> Option<Statements> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "statements")
            .map(|n| Statements::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_statements(&self) -> Vec<Statements> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "statements")
            .map(|n| Statements::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for TryExpression<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref TypeAliasId: u16 = crate::LANGUAGE.id_for_node_kind("type_alias", true);
}
pub struct TypeAlias<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> TypeAlias<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_function_type(&self) -> Option<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_type")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_type(&self) -> Vec<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_type")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_modifiers(&self) -> Option<Modifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "modifiers")
            .map(|n| Modifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_modifiers(&self) -> Vec<Modifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "modifiers")
            .map(|n| Modifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_not_nullable_type(&self) -> Option<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "not_nullable_type")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_not_nullable_type(&self) -> Vec<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "not_nullable_type")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_nullable_type(&self) -> Option<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "nullable_type")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_nullable_type(&self) -> Vec<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "nullable_type")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_type(&self) -> Option<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_type")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_type(&self) -> Vec<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_type")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_identifier(&self) -> Option<TypeIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_identifier(&self) -> Vec<TypeIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_modifiers(&self) -> Option<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_modifiers")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_modifiers(&self) -> Vec<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_modifiers")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_parameters(&self) -> Option<TypeParameters> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_parameters")
            .map(|n| TypeParameters::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_parameters(&self) -> Vec<TypeParameters> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_parameters")
            .map(|n| TypeParameters::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_user_type(&self) -> Option<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "user_type")
            .map(|n| UserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_user_type(&self) -> Vec<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "user_type")
            .map(|n| UserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for TypeAlias<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref TypeArgumentsId: u16 = crate::LANGUAGE.id_for_node_kind("type_arguments", true);
}
pub struct TypeArguments<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> TypeArguments<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_type_projection(&self) -> Option<TypeProjection> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_projection")
            .map(|n| TypeProjection::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_projection(&self) -> Vec<TypeProjection> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_projection")
            .map(|n| TypeProjection::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for TypeArguments<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref TypeConstraintId: u16 = crate::LANGUAGE.id_for_node_kind("type_constraint", true);
}
pub struct TypeConstraint<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> TypeConstraint<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_annotation(&self) -> Option<Annotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "annotation")
            .map(|n| Annotation::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_annotation(&self) -> Vec<Annotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "annotation")
            .map(|n| Annotation::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_function_type(&self) -> Option<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_type")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_type(&self) -> Vec<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_type")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_not_nullable_type(&self) -> Option<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "not_nullable_type")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_not_nullable_type(&self) -> Vec<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "not_nullable_type")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_nullable_type(&self) -> Option<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "nullable_type")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_nullable_type(&self) -> Vec<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "nullable_type")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_type(&self) -> Option<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_type")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_type(&self) -> Vec<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_type")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_identifier(&self) -> Option<TypeIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_identifier(&self) -> Vec<TypeIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_modifiers(&self) -> Option<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_modifiers")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_modifiers(&self) -> Vec<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_modifiers")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_user_type(&self) -> Option<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "user_type")
            .map(|n| UserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_user_type(&self) -> Vec<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "user_type")
            .map(|n| UserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for TypeConstraint<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref TypeConstraintsId: u16 = crate::LANGUAGE.id_for_node_kind("type_constraints", true);
}
pub struct TypeConstraints<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> TypeConstraints<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_type_constraint(&self) -> Option<TypeConstraint> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_constraint")
            .map(|n| TypeConstraint::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_constraint(&self) -> Vec<TypeConstraint> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_constraint")
            .map(|n| TypeConstraint::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for TypeConstraints<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref TypeIdentifierId: u16 = crate::LANGUAGE.id_for_node_kind("type_identifier", true);
}
pub struct TypeIdentifier<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> TypeIdentifier<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }}

impl<'a> std::fmt::Debug for TypeIdentifier<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref TypeModifiersId: u16 = crate::LANGUAGE.id_for_node_kind("type_modifiers", true);
}
pub struct TypeModifiers<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> TypeModifiers<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_annotation(&self) -> Option<Annotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "annotation")
            .map(|n| Annotation::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_annotation(&self) -> Vec<Annotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "annotation")
            .map(|n| Annotation::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for TypeModifiers<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref TypeParameterId: u16 = crate::LANGUAGE.id_for_node_kind("type_parameter", true);
}
pub struct TypeParameter<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> TypeParameter<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_function_type(&self) -> Option<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_type")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_type(&self) -> Vec<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_type")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_not_nullable_type(&self) -> Option<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "not_nullable_type")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_not_nullable_type(&self) -> Vec<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "not_nullable_type")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_nullable_type(&self) -> Option<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "nullable_type")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_nullable_type(&self) -> Vec<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "nullable_type")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_type(&self) -> Option<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_type")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_type(&self) -> Vec<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_type")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_identifier(&self) -> Option<TypeIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_identifier(&self) -> Vec<TypeIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_modifiers(&self) -> Option<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_modifiers")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_modifiers(&self) -> Vec<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_modifiers")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_parameter_modifiers(&self) -> Option<TypeParameterModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_parameter_modifiers")
            .map(|n| TypeParameterModifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_parameter_modifiers(&self) -> Vec<TypeParameterModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_parameter_modifiers")
            .map(|n| TypeParameterModifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_user_type(&self) -> Option<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "user_type")
            .map(|n| UserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_user_type(&self) -> Vec<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "user_type")
            .map(|n| UserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for TypeParameter<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref TypeParameterModifiersId: u16 = crate::LANGUAGE.id_for_node_kind("type_parameter_modifiers", true);
}
pub struct TypeParameterModifiers<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> TypeParameterModifiers<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_annotation(&self) -> Option<Annotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "annotation")
            .map(|n| Annotation::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_annotation(&self) -> Vec<Annotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "annotation")
            .map(|n| Annotation::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_reification_modifier(&self) -> Option<ReificationModifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "reification_modifier")
            .map(|n| ReificationModifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_reification_modifier(&self) -> Vec<ReificationModifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "reification_modifier")
            .map(|n| ReificationModifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_variance_modifier(&self) -> Option<VarianceModifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "variance_modifier")
            .map(|n| VarianceModifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_variance_modifier(&self) -> Vec<VarianceModifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "variance_modifier")
            .map(|n| VarianceModifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for TypeParameterModifiers<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref TypeParametersId: u16 = crate::LANGUAGE.id_for_node_kind("type_parameters", true);
}
pub struct TypeParameters<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> TypeParameters<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_type_parameter(&self) -> Option<TypeParameter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_parameter")
            .map(|n| TypeParameter::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_parameter(&self) -> Vec<TypeParameter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_parameter")
            .map(|n| TypeParameter::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for TypeParameters<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref TypeProjectionId: u16 = crate::LANGUAGE.id_for_node_kind("type_projection", true);
}
pub struct TypeProjection<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> TypeProjection<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_function_type(&self) -> Option<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_type")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_type(&self) -> Vec<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_type")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_not_nullable_type(&self) -> Option<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "not_nullable_type")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_not_nullable_type(&self) -> Vec<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "not_nullable_type")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_nullable_type(&self) -> Option<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "nullable_type")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_nullable_type(&self) -> Vec<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "nullable_type")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_type(&self) -> Option<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_type")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_type(&self) -> Vec<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_type")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_modifiers(&self) -> Option<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_modifiers")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_modifiers(&self) -> Vec<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_modifiers")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_projection_modifiers(&self) -> Option<TypeProjectionModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_projection_modifiers")
            .map(|n| TypeProjectionModifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_projection_modifiers(&self) -> Vec<TypeProjectionModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_projection_modifiers")
            .map(|n| TypeProjectionModifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_user_type(&self) -> Option<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "user_type")
            .map(|n| UserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_user_type(&self) -> Vec<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "user_type")
            .map(|n| UserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for TypeProjection<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref TypeProjectionModifiersId: u16 = crate::LANGUAGE.id_for_node_kind("type_projection_modifiers", true);
}
pub struct TypeProjectionModifiers<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> TypeProjectionModifiers<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_variance_modifier(&self) -> Option<VarianceModifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "variance_modifier")
            .map(|n| VarianceModifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_variance_modifier(&self) -> Vec<VarianceModifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "variance_modifier")
            .map(|n| VarianceModifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for TypeProjectionModifiers<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref TypeTestId: u16 = crate::LANGUAGE.id_for_node_kind("type_test", true);
}
pub struct TypeTest<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> TypeTest<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_function_type(&self) -> Option<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_type")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_type(&self) -> Vec<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_type")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_not_nullable_type(&self) -> Option<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "not_nullable_type")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_not_nullable_type(&self) -> Vec<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "not_nullable_type")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_nullable_type(&self) -> Option<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "nullable_type")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_nullable_type(&self) -> Vec<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "nullable_type")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_type(&self) -> Option<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_type")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_type(&self) -> Vec<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_type")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_modifiers(&self) -> Option<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_modifiers")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_modifiers(&self) -> Vec<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_modifiers")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_user_type(&self) -> Option<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "user_type")
            .map(|n| UserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_user_type(&self) -> Vec<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "user_type")
            .map(|n| UserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for TypeTest<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref UnsignedLiteralId: u16 = crate::LANGUAGE.id_for_node_kind("unsigned_literal", true);
}
pub struct UnsignedLiteral<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> UnsignedLiteral<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for UnsignedLiteral<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref UseSiteTargetId: u16 = crate::LANGUAGE.id_for_node_kind("use_site_target", true);
}
pub struct UseSiteTarget<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> UseSiteTarget<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }}

impl<'a> std::fmt::Debug for UseSiteTarget<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref UserTypeId: u16 = crate::LANGUAGE.id_for_node_kind("user_type", true);
}
pub struct UserType<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> UserType<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_type_arguments(&self) -> Option<TypeArguments> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_arguments")
            .map(|n| TypeArguments::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_arguments(&self) -> Vec<TypeArguments> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_arguments")
            .map(|n| TypeArguments::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_identifier(&self) -> Option<TypeIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_identifier(&self) -> Vec<TypeIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for UserType<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref ValueArgumentId: u16 = crate::LANGUAGE.id_for_node_kind("value_argument", true);
}
pub struct ValueArgument<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> ValueArgument<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_annotation(&self) -> Option<Annotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "annotation")
            .map(|n| Annotation::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_annotation(&self) -> Vec<Annotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "annotation")
            .map(|n| Annotation::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for ValueArgument<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref ValueArgumentsId: u16 = crate::LANGUAGE.id_for_node_kind("value_arguments", true);
}
pub struct ValueArguments<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> ValueArguments<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_value_argument(&self) -> Option<ValueArgument> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "value_argument")
            .map(|n| ValueArgument::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_value_argument(&self) -> Vec<ValueArgument> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "value_argument")
            .map(|n| ValueArgument::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for ValueArguments<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref VariableDeclarationId: u16 = crate::LANGUAGE.id_for_node_kind("variable_declaration", true);
}
pub struct VariableDeclaration<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> VariableDeclaration<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_function_type(&self) -> Option<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_type")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_type(&self) -> Vec<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "function_type")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_not_nullable_type(&self) -> Option<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "not_nullable_type")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_not_nullable_type(&self) -> Vec<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "not_nullable_type")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_nullable_type(&self) -> Option<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "nullable_type")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_nullable_type(&self) -> Vec<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "nullable_type")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_type(&self) -> Option<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_type")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_type(&self) -> Vec<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_type")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_modifiers(&self) -> Option<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_modifiers")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_modifiers(&self) -> Vec<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_modifiers")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_user_type(&self) -> Option<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "user_type")
            .map(|n| UserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_user_type(&self) -> Vec<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "user_type")
            .map(|n| UserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for VariableDeclaration<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref VarianceModifierId: u16 = crate::LANGUAGE.id_for_node_kind("variance_modifier", true);
}
pub struct VarianceModifier<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> VarianceModifier<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }}

impl<'a> std::fmt::Debug for VarianceModifier<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref VisibilityModifierId: u16 = crate::LANGUAGE.id_for_node_kind("visibility_modifier", true);
}
pub struct VisibilityModifier<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> VisibilityModifier<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }}

impl<'a> std::fmt::Debug for VisibilityModifier<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref WhenConditionId: u16 = crate::LANGUAGE.id_for_node_kind("when_condition", true);
}
pub struct WhenCondition<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> WhenCondition<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_test(&self) -> Option<RangeTest> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_test")
            .map(|n| RangeTest::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_test(&self) -> Vec<RangeTest> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_test")
            .map(|n| RangeTest::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_test(&self) -> Option<TypeTest> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_test")
            .map(|n| TypeTest::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_test(&self) -> Vec<TypeTest> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_test")
            .map(|n| TypeTest::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for WhenCondition<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref WhenEntryId: u16 = crate::LANGUAGE.id_for_node_kind("when_entry", true);
}
pub struct WhenEntry<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> WhenEntry<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_control_structure_body(&self) -> Option<ControlStructureBody> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "control_structure_body")
            .map(|n| ControlStructureBody::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_control_structure_body(&self) -> Vec<ControlStructureBody> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "control_structure_body")
            .map(|n| ControlStructureBody::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_condition(&self) -> Option<WhenCondition> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_condition")
            .map(|n| WhenCondition::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_condition(&self) -> Vec<WhenCondition> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_condition")
            .map(|n| WhenCondition::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for WhenEntry<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref WhenExpressionId: u16 = crate::LANGUAGE.id_for_node_kind("when_expression", true);
}
pub struct WhenExpression<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> WhenExpression<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_when_entry(&self) -> Option<WhenEntry> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_entry")
            .map(|n| WhenEntry::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_entry(&self) -> Vec<WhenEntry> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_entry")
            .map(|n| WhenEntry::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_subject(&self) -> Option<WhenSubject> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_subject")
            .map(|n| WhenSubject::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_subject(&self) -> Vec<WhenSubject> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_subject")
            .map(|n| WhenSubject::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for WhenExpression<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref WhenSubjectId: u16 = crate::LANGUAGE.id_for_node_kind("when_subject", true);
}
pub struct WhenSubject<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> WhenSubject<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_annotation(&self) -> Option<Annotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "annotation")
            .map(|n| Annotation::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_annotation(&self) -> Vec<Annotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "annotation")
            .map(|n| Annotation::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_variable_declaration(&self) -> Option<VariableDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "variable_declaration")
            .map(|n| VariableDeclaration::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_variable_declaration(&self) -> Vec<VariableDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "variable_declaration")
            .map(|n| VariableDeclaration::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for WhenSubject<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref WhileStatementId: u16 = crate::LANGUAGE.id_for_node_kind("while_statement", true);
}
pub struct WhileStatement<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> WhileStatement<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "additive_expression")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "anonymous_function")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "as_expression")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "bin_literal")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "boolean_literal")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "call_expression")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "callable_reference")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "character_literal")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "check_expression")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "collection_literal")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "comparison_expression")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "conjunction_expression")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_control_structure_body(&self) -> Option<ControlStructureBody> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "control_structure_body")
            .map(|n| ControlStructureBody::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_control_structure_body(&self) -> Vec<ControlStructureBody> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "control_structure_body")
            .map(|n| ControlStructureBody::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "disjunction_expression")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "elvis_expression")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "equality_expression")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "hex_literal")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "if_expression")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "indexing_expression")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "infix_expression")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "integer_literal")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "jump_expression")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "lambda_literal")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "long_literal")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "multiplicative_expression")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "navigation_expression")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "null_literal")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "object_literal")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "parenthesized_expression")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "postfix_expression")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "prefix_expression")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "range_expression")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "real_literal")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "simple_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "spread_expression")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "string_literal")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "super_expression")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "this_expression")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "try_expression")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "unsigned_literal")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "when_expression")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for WhileStatement<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref BinLiteralId: u16 = crate::LANGUAGE.id_for_node_kind("bin_literal", true);
}
pub struct BinLiteral<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> BinLiteral<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }}

impl<'a> std::fmt::Debug for BinLiteral<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref HexLiteralId: u16 = crate::LANGUAGE.id_for_node_kind("hex_literal", true);
}
pub struct HexLiteral<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> HexLiteral<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }}

impl<'a> std::fmt::Debug for HexLiteral<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref IntegerLiteralId: u16 = crate::LANGUAGE.id_for_node_kind("integer_literal", true);
}
pub struct IntegerLiteral<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> IntegerLiteral<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }}

impl<'a> std::fmt::Debug for IntegerLiteral<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref LineCommentId: u16 = crate::LANGUAGE.id_for_node_kind("line_comment", true);
}
pub struct LineComment<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> LineComment<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }}

impl<'a> std::fmt::Debug for LineComment<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref MultilineCommentId: u16 = crate::LANGUAGE.id_for_node_kind("multiline_comment", true);
}
pub struct MultilineComment<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> MultilineComment<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }}

impl<'a> std::fmt::Debug for MultilineComment<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref NullLiteralId: u16 = crate::LANGUAGE.id_for_node_kind("null_literal", true);
}
pub struct NullLiteral<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> NullLiteral<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }}

impl<'a> std::fmt::Debug for NullLiteral<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref PropertyModifierId: u16 = crate::LANGUAGE.id_for_node_kind("property_modifier", true);
}
pub struct PropertyModifier<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> PropertyModifier<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }}

impl<'a> std::fmt::Debug for PropertyModifier<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref RealLiteralId: u16 = crate::LANGUAGE.id_for_node_kind("real_literal", true);
}
pub struct RealLiteral<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> RealLiteral<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }}

impl<'a> std::fmt::Debug for RealLiteral<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref ReificationModifierId: u16 = crate::LANGUAGE.id_for_node_kind("reification_modifier", true);
}
pub struct ReificationModifier<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> ReificationModifier<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }}

impl<'a> std::fmt::Debug for ReificationModifier<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref StringContentId: u16 = crate::LANGUAGE.id_for_node_kind("string_content", true);
}
pub struct StringContent<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> StringContent<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }}

impl<'a> std::fmt::Debug for StringContent<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}lazy_static!{
    pub static ref WildcardImportId: u16 = crate::LANGUAGE.id_for_node_kind("wildcard_import", true);
}
pub struct WildcardImport<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> WildcardImport<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }

    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }

    pub fn text_tr(&self) -> WithTR<String> {
        WithTR::new(self.text_range(), self.text())
    }

    pub fn text_range(&self) -> TextRange {
        self.node.byte_range().try_into().unwrap()
    }}

impl<'a> std::fmt::Debug for WildcardImport<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}
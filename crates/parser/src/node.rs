// src/nodes.rs is autogeneratd from templates/nodes.rs

use crop::Rope;
use tree_sitter::Node;

use crate::text_of;

// for w/e reasons looking up the child by field_name doesn't work
// so we filter on kind
pub struct AdditiveExpression<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> AdditiveExpression<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for AdditiveExpression<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct AnnotatedLambda<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> AnnotatedLambda<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_annotation(&self) -> Option<Annotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Annotation::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_annotation(&self) -> Vec<Annotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Annotation::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_label(&self) -> Option<Label> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Label::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_label(&self) -> Vec<Label> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Label::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for AnnotatedLambda<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct Annotation<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> Annotation<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_constructor_invocation(&self) -> Option<ConstructorInvocation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConstructorInvocation::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_constructor_invocation(&self) -> Vec<ConstructorInvocation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConstructorInvocation::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_use_site_target(&self) -> Option<UseSiteTarget> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UseSiteTarget::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_use_site_target(&self) -> Vec<UseSiteTarget> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UseSiteTarget::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_user_type(&self) -> Option<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_user_type(&self) -> Vec<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for Annotation<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct AnonymousFunction<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> AnonymousFunction<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_function_body(&self) -> Option<FunctionBody> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionBody::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_body(&self) -> Vec<FunctionBody> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionBody::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_function_type(&self) -> Option<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_type(&self) -> Vec<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_function_value_parameters(&self) -> Option<FunctionValueParameters> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionValueParameters::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_value_parameters(&self) -> Vec<FunctionValueParameters> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionValueParameters::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_not_nullable_type(&self) -> Option<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_not_nullable_type(&self) -> Vec<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_nullable_type(&self) -> Option<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_nullable_type(&self) -> Vec<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_type(&self) -> Option<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_type(&self) -> Vec<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_arguments(&self) -> Option<TypeArguments> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeArguments::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_arguments(&self) -> Vec<TypeArguments> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeArguments::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_identifier(&self) -> Option<TypeIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_identifier(&self) -> Vec<TypeIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_modifiers(&self) -> Option<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_modifiers(&self) -> Vec<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_user_type(&self) -> Option<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_user_type(&self) -> Vec<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for AnonymousFunction<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct AnonymousInitializer<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> AnonymousInitializer<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_statements(&self) -> Option<Statements> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Statements::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_statements(&self) -> Vec<Statements> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Statements::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for AnonymousInitializer<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct AsExpression<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> AsExpression<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_function_type(&self) -> Option<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_type(&self) -> Vec<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_not_nullable_type(&self) -> Option<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_not_nullable_type(&self) -> Vec<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_nullable_type(&self) -> Option<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_nullable_type(&self) -> Vec<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_type(&self) -> Option<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_type(&self) -> Vec<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_modifiers(&self) -> Option<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_modifiers(&self) -> Vec<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_user_type(&self) -> Option<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_user_type(&self) -> Vec<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for AsExpression<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct Assignment<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> Assignment<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_directly_assignable_expression(&self) -> Option<DirectlyAssignableExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DirectlyAssignableExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_directly_assignable_expression(&self) -> Vec<DirectlyAssignableExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DirectlyAssignableExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for Assignment<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct BindingPatternKind<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> BindingPatternKind<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }}

impl<'a> std::fmt::Debug for BindingPatternKind<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct BooleanLiteral<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> BooleanLiteral<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }}

impl<'a> std::fmt::Debug for BooleanLiteral<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct CallExpression<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> CallExpression<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_suffix(&self) -> Option<CallSuffix> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallSuffix::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_suffix(&self) -> Vec<CallSuffix> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallSuffix::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for CallExpression<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct CallSuffix<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> CallSuffix<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_annotated_lambda(&self) -> Option<AnnotatedLambda> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnnotatedLambda::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_annotated_lambda(&self) -> Vec<AnnotatedLambda> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnnotatedLambda::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_arguments(&self) -> Option<TypeArguments> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeArguments::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_arguments(&self) -> Vec<TypeArguments> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeArguments::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_value_arguments(&self) -> Option<ValueArguments> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ValueArguments::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_value_arguments(&self) -> Vec<ValueArguments> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ValueArguments::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for CallSuffix<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct CallableReference<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> CallableReference<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_identifier(&self) -> Option<TypeIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_identifier(&self) -> Vec<TypeIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for CallableReference<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct CatchBlock<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> CatchBlock<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_annotation(&self) -> Option<Annotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Annotation::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_annotation(&self) -> Vec<Annotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Annotation::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_function_type(&self) -> Option<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_type(&self) -> Vec<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_not_nullable_type(&self) -> Option<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_not_nullable_type(&self) -> Vec<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_nullable_type(&self) -> Option<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_nullable_type(&self) -> Vec<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_type(&self) -> Option<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_type(&self) -> Vec<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_statements(&self) -> Option<Statements> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Statements::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_statements(&self) -> Vec<Statements> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Statements::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_modifiers(&self) -> Option<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_modifiers(&self) -> Vec<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_user_type(&self) -> Option<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_user_type(&self) -> Vec<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for CatchBlock<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct CharacterEscapeSeq<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> CharacterEscapeSeq<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }}

impl<'a> std::fmt::Debug for CharacterEscapeSeq<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct CharacterLiteral<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> CharacterLiteral<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_character_escape_seq(&self) -> Option<CharacterEscapeSeq> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterEscapeSeq::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_escape_seq(&self) -> Vec<CharacterEscapeSeq> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterEscapeSeq::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for CharacterLiteral<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct CheckExpression<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> CheckExpression<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_function_type(&self) -> Option<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_type(&self) -> Vec<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_not_nullable_type(&self) -> Option<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_not_nullable_type(&self) -> Vec<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_nullable_type(&self) -> Option<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_nullable_type(&self) -> Vec<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_type(&self) -> Option<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_type(&self) -> Vec<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_modifiers(&self) -> Option<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_modifiers(&self) -> Vec<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_user_type(&self) -> Option<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_user_type(&self) -> Vec<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for CheckExpression<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct ClassBody<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> ClassBody<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_anonymous_initializer(&self) -> Option<AnonymousInitializer> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousInitializer::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_initializer(&self) -> Vec<AnonymousInitializer> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousInitializer::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_class_declaration(&self) -> Option<ClassDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ClassDeclaration::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_class_declaration(&self) -> Vec<ClassDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ClassDeclaration::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_companion_object(&self) -> Option<CompanionObject> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CompanionObject::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_companion_object(&self) -> Vec<CompanionObject> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CompanionObject::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_function_declaration(&self) -> Option<FunctionDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionDeclaration::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_declaration(&self) -> Vec<FunctionDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionDeclaration::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_getter(&self) -> Option<Getter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Getter::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_getter(&self) -> Vec<Getter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Getter::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_declaration(&self) -> Option<ObjectDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectDeclaration::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_declaration(&self) -> Vec<ObjectDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectDeclaration::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_property_declaration(&self) -> Option<PropertyDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PropertyDeclaration::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_property_declaration(&self) -> Vec<PropertyDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PropertyDeclaration::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_secondary_constructor(&self) -> Option<SecondaryConstructor> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SecondaryConstructor::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_secondary_constructor(&self) -> Vec<SecondaryConstructor> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SecondaryConstructor::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_setter(&self) -> Option<Setter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Setter::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_setter(&self) -> Vec<Setter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Setter::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_alias(&self) -> Option<TypeAlias> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeAlias::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_alias(&self) -> Vec<TypeAlias> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeAlias::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for ClassBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct ClassDeclaration<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> ClassDeclaration<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_class_body(&self) -> Option<ClassBody> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ClassBody::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_class_body(&self) -> Vec<ClassBody> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ClassBody::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_delegation_specifier(&self) -> Option<DelegationSpecifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DelegationSpecifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_delegation_specifier(&self) -> Vec<DelegationSpecifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DelegationSpecifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_enum_class_body(&self) -> Option<EnumClassBody> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EnumClassBody::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_enum_class_body(&self) -> Vec<EnumClassBody> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EnumClassBody::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_modifiers(&self) -> Option<Modifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Modifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_modifiers(&self) -> Vec<Modifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Modifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_primary_constructor(&self) -> Option<PrimaryConstructor> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrimaryConstructor::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_primary_constructor(&self) -> Vec<PrimaryConstructor> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrimaryConstructor::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_constraints(&self) -> Option<TypeConstraints> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeConstraints::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_constraints(&self) -> Vec<TypeConstraints> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeConstraints::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_identifier(&self) -> Option<TypeIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_identifier(&self) -> Vec<TypeIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_parameters(&self) -> Option<TypeParameters> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeParameters::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_parameters(&self) -> Vec<TypeParameters> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeParameters::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for ClassDeclaration<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct ClassModifier<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> ClassModifier<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }}

impl<'a> std::fmt::Debug for ClassModifier<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct ClassParameter<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> ClassParameter<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_binding_pattern_kind(&self) -> Option<BindingPatternKind> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BindingPatternKind::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_binding_pattern_kind(&self) -> Vec<BindingPatternKind> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BindingPatternKind::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_function_type(&self) -> Option<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_type(&self) -> Vec<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_modifiers(&self) -> Option<Modifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Modifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_modifiers(&self) -> Vec<Modifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Modifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_not_nullable_type(&self) -> Option<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_not_nullable_type(&self) -> Vec<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_nullable_type(&self) -> Option<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_nullable_type(&self) -> Vec<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_type(&self) -> Option<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_type(&self) -> Vec<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_modifiers(&self) -> Option<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_modifiers(&self) -> Vec<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_user_type(&self) -> Option<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_user_type(&self) -> Vec<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for ClassParameter<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct CollectionLiteral<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> CollectionLiteral<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for CollectionLiteral<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct CompanionObject<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> CompanionObject<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_class_body(&self) -> Option<ClassBody> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ClassBody::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_class_body(&self) -> Vec<ClassBody> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ClassBody::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_delegation_specifier(&self) -> Option<DelegationSpecifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DelegationSpecifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_delegation_specifier(&self) -> Vec<DelegationSpecifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DelegationSpecifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_modifiers(&self) -> Option<Modifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Modifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_modifiers(&self) -> Vec<Modifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Modifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_identifier(&self) -> Option<TypeIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_identifier(&self) -> Vec<TypeIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for CompanionObject<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct ComparisonExpression<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> ComparisonExpression<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for ComparisonExpression<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct ConjunctionExpression<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> ConjunctionExpression<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for ConjunctionExpression<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct ConstructorDelegationCall<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> ConstructorDelegationCall<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_value_arguments(&self) -> Option<ValueArguments> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ValueArguments::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_value_arguments(&self) -> Vec<ValueArguments> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ValueArguments::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for ConstructorDelegationCall<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct ConstructorInvocation<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> ConstructorInvocation<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_user_type(&self) -> Option<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_user_type(&self) -> Vec<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_value_arguments(&self) -> Option<ValueArguments> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ValueArguments::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_value_arguments(&self) -> Vec<ValueArguments> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ValueArguments::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for ConstructorInvocation<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct ControlStructureBody<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> ControlStructureBody<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_annotation(&self) -> Option<Annotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Annotation::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_annotation(&self) -> Vec<Annotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Annotation::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_assignment(&self) -> Option<Assignment> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Assignment::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_assignment(&self) -> Vec<Assignment> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Assignment::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_class_declaration(&self) -> Option<ClassDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ClassDeclaration::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_class_declaration(&self) -> Vec<ClassDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ClassDeclaration::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_do_while_statement(&self) -> Option<DoWhileStatement> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DoWhileStatement::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_do_while_statement(&self) -> Vec<DoWhileStatement> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DoWhileStatement::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_for_statement(&self) -> Option<ForStatement> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ForStatement::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_for_statement(&self) -> Vec<ForStatement> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ForStatement::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_function_declaration(&self) -> Option<FunctionDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionDeclaration::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_declaration(&self) -> Vec<FunctionDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionDeclaration::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_getter(&self) -> Option<Getter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Getter::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_getter(&self) -> Vec<Getter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Getter::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_label(&self) -> Option<Label> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Label::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_label(&self) -> Vec<Label> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Label::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_declaration(&self) -> Option<ObjectDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectDeclaration::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_declaration(&self) -> Vec<ObjectDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectDeclaration::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_property_declaration(&self) -> Option<PropertyDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PropertyDeclaration::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_property_declaration(&self) -> Vec<PropertyDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PropertyDeclaration::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_setter(&self) -> Option<Setter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Setter::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_setter(&self) -> Vec<Setter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Setter::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_statements(&self) -> Option<Statements> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Statements::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_statements(&self) -> Vec<Statements> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Statements::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_alias(&self) -> Option<TypeAlias> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeAlias::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_alias(&self) -> Vec<TypeAlias> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeAlias::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_while_statement(&self) -> Option<WhileStatement> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhileStatement::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_while_statement(&self) -> Vec<WhileStatement> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhileStatement::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for ControlStructureBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct DelegationSpecifier<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> DelegationSpecifier<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_constructor_invocation(&self) -> Option<ConstructorInvocation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConstructorInvocation::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_constructor_invocation(&self) -> Vec<ConstructorInvocation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConstructorInvocation::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_explicit_delegation(&self) -> Option<ExplicitDelegation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ExplicitDelegation::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_explicit_delegation(&self) -> Vec<ExplicitDelegation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ExplicitDelegation::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_function_type(&self) -> Option<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_type(&self) -> Vec<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_user_type(&self) -> Option<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_user_type(&self) -> Vec<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for DelegationSpecifier<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct DirectlyAssignableExpression<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> DirectlyAssignableExpression<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_suffix(&self) -> Option<IndexingSuffix> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingSuffix::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_suffix(&self) -> Vec<IndexingSuffix> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingSuffix::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_suffix(&self) -> Option<NavigationSuffix> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationSuffix::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_suffix(&self) -> Vec<NavigationSuffix> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationSuffix::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for DirectlyAssignableExpression<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct DisjunctionExpression<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> DisjunctionExpression<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for DisjunctionExpression<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct DoWhileStatement<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> DoWhileStatement<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_control_structure_body(&self) -> Option<ControlStructureBody> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ControlStructureBody::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_control_structure_body(&self) -> Vec<ControlStructureBody> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ControlStructureBody::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for DoWhileStatement<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct ElvisExpression<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> ElvisExpression<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for ElvisExpression<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct EnumClassBody<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> EnumClassBody<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_anonymous_initializer(&self) -> Option<AnonymousInitializer> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousInitializer::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_initializer(&self) -> Vec<AnonymousInitializer> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousInitializer::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_class_declaration(&self) -> Option<ClassDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ClassDeclaration::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_class_declaration(&self) -> Vec<ClassDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ClassDeclaration::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_companion_object(&self) -> Option<CompanionObject> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CompanionObject::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_companion_object(&self) -> Vec<CompanionObject> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CompanionObject::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_enum_entry(&self) -> Option<EnumEntry> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EnumEntry::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_enum_entry(&self) -> Vec<EnumEntry> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EnumEntry::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_function_declaration(&self) -> Option<FunctionDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionDeclaration::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_declaration(&self) -> Vec<FunctionDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionDeclaration::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_getter(&self) -> Option<Getter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Getter::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_getter(&self) -> Vec<Getter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Getter::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_declaration(&self) -> Option<ObjectDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectDeclaration::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_declaration(&self) -> Vec<ObjectDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectDeclaration::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_property_declaration(&self) -> Option<PropertyDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PropertyDeclaration::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_property_declaration(&self) -> Vec<PropertyDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PropertyDeclaration::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_secondary_constructor(&self) -> Option<SecondaryConstructor> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SecondaryConstructor::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_secondary_constructor(&self) -> Vec<SecondaryConstructor> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SecondaryConstructor::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_setter(&self) -> Option<Setter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Setter::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_setter(&self) -> Vec<Setter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Setter::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_alias(&self) -> Option<TypeAlias> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeAlias::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_alias(&self) -> Vec<TypeAlias> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeAlias::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for EnumClassBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct EnumEntry<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> EnumEntry<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_class_body(&self) -> Option<ClassBody> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ClassBody::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_class_body(&self) -> Vec<ClassBody> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ClassBody::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_modifiers(&self) -> Option<Modifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Modifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_modifiers(&self) -> Vec<Modifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Modifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_value_arguments(&self) -> Option<ValueArguments> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ValueArguments::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_value_arguments(&self) -> Vec<ValueArguments> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ValueArguments::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for EnumEntry<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct EqualityExpression<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> EqualityExpression<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for EqualityExpression<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct ExplicitDelegation<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> ExplicitDelegation<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_function_type(&self) -> Option<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_type(&self) -> Vec<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_user_type(&self) -> Option<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_user_type(&self) -> Vec<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for ExplicitDelegation<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct FileAnnotation<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> FileAnnotation<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_constructor_invocation(&self) -> Option<ConstructorInvocation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConstructorInvocation::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_constructor_invocation(&self) -> Vec<ConstructorInvocation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConstructorInvocation::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_user_type(&self) -> Option<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_user_type(&self) -> Vec<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for FileAnnotation<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct FinallyBlock<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> FinallyBlock<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_statements(&self) -> Option<Statements> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Statements::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_statements(&self) -> Vec<Statements> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Statements::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for FinallyBlock<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct ForStatement<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> ForStatement<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_annotation(&self) -> Option<Annotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Annotation::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_annotation(&self) -> Vec<Annotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Annotation::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_control_structure_body(&self) -> Option<ControlStructureBody> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ControlStructureBody::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_control_structure_body(&self) -> Vec<ControlStructureBody> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ControlStructureBody::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multi_variable_declaration(&self) -> Option<MultiVariableDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiVariableDeclaration::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multi_variable_declaration(&self) -> Vec<MultiVariableDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiVariableDeclaration::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_variable_declaration(&self) -> Option<VariableDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| VariableDeclaration::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_variable_declaration(&self) -> Vec<VariableDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| VariableDeclaration::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for ForStatement<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct FunctionBody<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> FunctionBody<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_statements(&self) -> Option<Statements> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Statements::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_statements(&self) -> Vec<Statements> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Statements::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for FunctionBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct FunctionDeclaration<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> FunctionDeclaration<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_function_body(&self) -> Option<FunctionBody> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionBody::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_body(&self) -> Vec<FunctionBody> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionBody::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_function_type(&self) -> Option<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_type(&self) -> Vec<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_function_value_parameters(&self) -> Option<FunctionValueParameters> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionValueParameters::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_value_parameters(&self) -> Vec<FunctionValueParameters> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionValueParameters::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_modifiers(&self) -> Option<Modifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Modifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_modifiers(&self) -> Vec<Modifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Modifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_not_nullable_type(&self) -> Option<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_not_nullable_type(&self) -> Vec<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_nullable_type(&self) -> Option<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_nullable_type(&self) -> Vec<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_type(&self) -> Option<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_type(&self) -> Vec<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_constraints(&self) -> Option<TypeConstraints> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeConstraints::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_constraints(&self) -> Vec<TypeConstraints> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeConstraints::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_modifiers(&self) -> Option<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_modifiers(&self) -> Vec<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_parameters(&self) -> Option<TypeParameters> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeParameters::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_parameters(&self) -> Vec<TypeParameters> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeParameters::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_user_type(&self) -> Option<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_user_type(&self) -> Vec<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for FunctionDeclaration<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct FunctionModifier<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> FunctionModifier<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }}

impl<'a> std::fmt::Debug for FunctionModifier<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct FunctionType<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> FunctionType<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_function_type(&self) -> Option<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_type(&self) -> Vec<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_function_type_parameters(&self) -> Option<FunctionTypeParameters> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionTypeParameters::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_type_parameters(&self) -> Vec<FunctionTypeParameters> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionTypeParameters::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_not_nullable_type(&self) -> Option<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_not_nullable_type(&self) -> Vec<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_nullable_type(&self) -> Option<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_nullable_type(&self) -> Vec<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_type(&self) -> Option<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_type(&self) -> Vec<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_arguments(&self) -> Option<TypeArguments> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeArguments::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_arguments(&self) -> Vec<TypeArguments> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeArguments::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_identifier(&self) -> Option<TypeIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_identifier(&self) -> Vec<TypeIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_modifiers(&self) -> Option<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_modifiers(&self) -> Vec<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_user_type(&self) -> Option<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_user_type(&self) -> Vec<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for FunctionType<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct FunctionTypeParameters<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> FunctionTypeParameters<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_function_type(&self) -> Option<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_type(&self) -> Vec<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_not_nullable_type(&self) -> Option<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_not_nullable_type(&self) -> Vec<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_nullable_type(&self) -> Option<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_nullable_type(&self) -> Vec<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parameter(&self) -> Option<Parameter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Parameter::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parameter(&self) -> Vec<Parameter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Parameter::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_type(&self) -> Option<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_type(&self) -> Vec<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_modifiers(&self) -> Option<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_modifiers(&self) -> Vec<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_user_type(&self) -> Option<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_user_type(&self) -> Vec<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for FunctionTypeParameters<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct FunctionValueParameters<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> FunctionValueParameters<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parameter(&self) -> Option<Parameter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Parameter::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parameter(&self) -> Vec<Parameter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Parameter::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parameter_modifiers(&self) -> Option<ParameterModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParameterModifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parameter_modifiers(&self) -> Vec<ParameterModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParameterModifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for FunctionValueParameters<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct Getter<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> Getter<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_function_body(&self) -> Option<FunctionBody> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionBody::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_body(&self) -> Vec<FunctionBody> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionBody::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_function_type(&self) -> Option<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_type(&self) -> Vec<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_modifiers(&self) -> Option<Modifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Modifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_modifiers(&self) -> Vec<Modifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Modifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_not_nullable_type(&self) -> Option<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_not_nullable_type(&self) -> Vec<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_nullable_type(&self) -> Option<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_nullable_type(&self) -> Vec<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_type(&self) -> Option<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_type(&self) -> Vec<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_modifiers(&self) -> Option<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_modifiers(&self) -> Vec<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_user_type(&self) -> Option<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_user_type(&self) -> Vec<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for Getter<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct Identifier<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> Identifier<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for Identifier<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct IfExpression<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> IfExpression<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }}

impl<'a> std::fmt::Debug for IfExpression<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct ImportAlias<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> ImportAlias<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_type_identifier(&self) -> Option<TypeIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_identifier(&self) -> Vec<TypeIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for ImportAlias<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct ImportHeader<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> ImportHeader<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_identifier(&self) -> Option<Identifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Identifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_identifier(&self) -> Vec<Identifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Identifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_import_alias(&self) -> Option<ImportAlias> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ImportAlias::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_import_alias(&self) -> Vec<ImportAlias> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ImportAlias::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_wildcard_import(&self) -> Option<WildcardImport> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WildcardImport::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_wildcard_import(&self) -> Vec<WildcardImport> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WildcardImport::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for ImportHeader<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct ImportList<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> ImportList<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_import_header(&self) -> Option<ImportHeader> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ImportHeader::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_import_header(&self) -> Vec<ImportHeader> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ImportHeader::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for ImportList<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct IndexingExpression<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> IndexingExpression<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_suffix(&self) -> Option<IndexingSuffix> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingSuffix::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_suffix(&self) -> Vec<IndexingSuffix> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingSuffix::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for IndexingExpression<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct IndexingSuffix<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> IndexingSuffix<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for IndexingSuffix<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct InfixExpression<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> InfixExpression<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for InfixExpression<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct InheritanceModifier<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> InheritanceModifier<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }}

impl<'a> std::fmt::Debug for InheritanceModifier<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct InterpolatedExpression<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> InterpolatedExpression<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for InterpolatedExpression<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct InterpolatedIdentifier<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> InterpolatedIdentifier<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }}

impl<'a> std::fmt::Debug for InterpolatedIdentifier<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct JumpExpression<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> JumpExpression<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_label(&self) -> Option<Label> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Label::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_label(&self) -> Vec<Label> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Label::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for JumpExpression<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct Label<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> Label<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }}

impl<'a> std::fmt::Debug for Label<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct LambdaLiteral<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> LambdaLiteral<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_lambda_parameters(&self) -> Option<LambdaParameters> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaParameters::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_parameters(&self) -> Vec<LambdaParameters> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaParameters::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_statements(&self) -> Option<Statements> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Statements::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_statements(&self) -> Vec<Statements> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Statements::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for LambdaLiteral<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct LambdaParameters<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> LambdaParameters<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_multi_variable_declaration(&self) -> Option<MultiVariableDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiVariableDeclaration::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multi_variable_declaration(&self) -> Vec<MultiVariableDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiVariableDeclaration::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_variable_declaration(&self) -> Option<VariableDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| VariableDeclaration::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_variable_declaration(&self) -> Vec<VariableDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| VariableDeclaration::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for LambdaParameters<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct LongLiteral<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> LongLiteral<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for LongLiteral<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct MemberModifier<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> MemberModifier<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }}

impl<'a> std::fmt::Debug for MemberModifier<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct Modifiers<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> Modifiers<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_annotation(&self) -> Option<Annotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Annotation::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_annotation(&self) -> Vec<Annotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Annotation::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_class_modifier(&self) -> Option<ClassModifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ClassModifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_class_modifier(&self) -> Vec<ClassModifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ClassModifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_function_modifier(&self) -> Option<FunctionModifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionModifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_modifier(&self) -> Vec<FunctionModifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionModifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_inheritance_modifier(&self) -> Option<InheritanceModifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InheritanceModifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_inheritance_modifier(&self) -> Vec<InheritanceModifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InheritanceModifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_member_modifier(&self) -> Option<MemberModifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MemberModifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_member_modifier(&self) -> Vec<MemberModifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MemberModifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parameter_modifier(&self) -> Option<ParameterModifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParameterModifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parameter_modifier(&self) -> Vec<ParameterModifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParameterModifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_platform_modifier(&self) -> Option<PlatformModifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PlatformModifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_platform_modifier(&self) -> Vec<PlatformModifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PlatformModifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_property_modifier(&self) -> Option<PropertyModifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PropertyModifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_property_modifier(&self) -> Vec<PropertyModifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PropertyModifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_visibility_modifier(&self) -> Option<VisibilityModifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| VisibilityModifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_visibility_modifier(&self) -> Vec<VisibilityModifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| VisibilityModifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for Modifiers<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct MultiVariableDeclaration<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> MultiVariableDeclaration<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_variable_declaration(&self) -> Option<VariableDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| VariableDeclaration::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_variable_declaration(&self) -> Vec<VariableDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| VariableDeclaration::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for MultiVariableDeclaration<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct MultiplicativeExpression<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> MultiplicativeExpression<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for MultiplicativeExpression<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct NavigationExpression<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> NavigationExpression<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_suffix(&self) -> Option<NavigationSuffix> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationSuffix::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_suffix(&self) -> Vec<NavigationSuffix> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationSuffix::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for NavigationExpression<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct NavigationSuffix<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> NavigationSuffix<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for NavigationSuffix<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct NotNullableType<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> NotNullableType<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_parenthesized_user_type(&self) -> Option<ParenthesizedUserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedUserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_user_type(&self) -> Vec<ParenthesizedUserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedUserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_modifiers(&self) -> Option<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_modifiers(&self) -> Vec<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_user_type(&self) -> Option<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_user_type(&self) -> Vec<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for NotNullableType<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct NullableType<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> NullableType<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_parenthesized_type(&self) -> Option<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_type(&self) -> Vec<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_user_type(&self) -> Option<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_user_type(&self) -> Vec<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for NullableType<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct ObjectDeclaration<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> ObjectDeclaration<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_class_body(&self) -> Option<ClassBody> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ClassBody::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_class_body(&self) -> Vec<ClassBody> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ClassBody::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_delegation_specifier(&self) -> Option<DelegationSpecifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DelegationSpecifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_delegation_specifier(&self) -> Vec<DelegationSpecifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DelegationSpecifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_modifiers(&self) -> Option<Modifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Modifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_modifiers(&self) -> Vec<Modifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Modifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_identifier(&self) -> Option<TypeIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_identifier(&self) -> Vec<TypeIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for ObjectDeclaration<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct ObjectLiteral<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> ObjectLiteral<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_class_body(&self) -> Option<ClassBody> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ClassBody::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_class_body(&self) -> Vec<ClassBody> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ClassBody::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_delegation_specifier(&self) -> Option<DelegationSpecifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DelegationSpecifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_delegation_specifier(&self) -> Vec<DelegationSpecifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DelegationSpecifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for ObjectLiteral<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct PackageHeader<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> PackageHeader<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_identifier(&self) -> Option<Identifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Identifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_identifier(&self) -> Vec<Identifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Identifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for PackageHeader<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct Parameter<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> Parameter<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_function_type(&self) -> Option<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_type(&self) -> Vec<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_not_nullable_type(&self) -> Option<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_not_nullable_type(&self) -> Vec<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_nullable_type(&self) -> Option<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_nullable_type(&self) -> Vec<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_type(&self) -> Option<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_type(&self) -> Vec<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_modifiers(&self) -> Option<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_modifiers(&self) -> Vec<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_user_type(&self) -> Option<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_user_type(&self) -> Vec<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for Parameter<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct ParameterModifier<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> ParameterModifier<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }}

impl<'a> std::fmt::Debug for ParameterModifier<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct ParameterModifiers<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> ParameterModifiers<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_annotation(&self) -> Option<Annotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Annotation::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_annotation(&self) -> Vec<Annotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Annotation::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parameter_modifier(&self) -> Option<ParameterModifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParameterModifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parameter_modifier(&self) -> Vec<ParameterModifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParameterModifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for ParameterModifiers<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct ParameterWithOptionalType<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> ParameterWithOptionalType<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_function_type(&self) -> Option<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_type(&self) -> Vec<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_not_nullable_type(&self) -> Option<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_not_nullable_type(&self) -> Vec<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_nullable_type(&self) -> Option<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_nullable_type(&self) -> Vec<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parameter_modifiers(&self) -> Option<ParameterModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParameterModifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parameter_modifiers(&self) -> Vec<ParameterModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParameterModifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_type(&self) -> Option<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_type(&self) -> Vec<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_modifiers(&self) -> Option<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_modifiers(&self) -> Vec<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_user_type(&self) -> Option<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_user_type(&self) -> Vec<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for ParameterWithOptionalType<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct ParenthesizedExpression<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> ParenthesizedExpression<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for ParenthesizedExpression<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct ParenthesizedType<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> ParenthesizedType<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_function_type(&self) -> Option<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_type(&self) -> Vec<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_not_nullable_type(&self) -> Option<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_not_nullable_type(&self) -> Vec<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_nullable_type(&self) -> Option<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_nullable_type(&self) -> Vec<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_type(&self) -> Option<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_type(&self) -> Vec<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_modifiers(&self) -> Option<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_modifiers(&self) -> Vec<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_user_type(&self) -> Option<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_user_type(&self) -> Vec<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for ParenthesizedType<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct ParenthesizedUserType<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> ParenthesizedUserType<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_parenthesized_user_type(&self) -> Option<ParenthesizedUserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedUserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_user_type(&self) -> Vec<ParenthesizedUserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedUserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_user_type(&self) -> Option<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_user_type(&self) -> Vec<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for ParenthesizedUserType<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct PlatformModifier<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> PlatformModifier<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }}

impl<'a> std::fmt::Debug for PlatformModifier<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct PostfixExpression<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> PostfixExpression<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for PostfixExpression<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct PrefixExpression<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> PrefixExpression<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_annotation(&self) -> Option<Annotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Annotation::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_annotation(&self) -> Vec<Annotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Annotation::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_label(&self) -> Option<Label> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Label::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_label(&self) -> Vec<Label> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Label::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for PrefixExpression<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct PrimaryConstructor<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> PrimaryConstructor<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_class_parameter(&self) -> Option<ClassParameter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ClassParameter::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_class_parameter(&self) -> Vec<ClassParameter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ClassParameter::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_modifiers(&self) -> Option<Modifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Modifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_modifiers(&self) -> Vec<Modifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Modifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for PrimaryConstructor<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct PropertyDeclaration<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> PropertyDeclaration<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_binding_pattern_kind(&self) -> Option<BindingPatternKind> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BindingPatternKind::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_binding_pattern_kind(&self) -> Vec<BindingPatternKind> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BindingPatternKind::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_getter(&self) -> Option<Getter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Getter::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_getter(&self) -> Vec<Getter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Getter::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_modifiers(&self) -> Option<Modifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Modifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_modifiers(&self) -> Vec<Modifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Modifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multi_variable_declaration(&self) -> Option<MultiVariableDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiVariableDeclaration::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multi_variable_declaration(&self) -> Vec<MultiVariableDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiVariableDeclaration::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_nullable_type(&self) -> Option<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_nullable_type(&self) -> Vec<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_type(&self) -> Option<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_type(&self) -> Vec<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_property_delegate(&self) -> Option<PropertyDelegate> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PropertyDelegate::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_property_delegate(&self) -> Vec<PropertyDelegate> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PropertyDelegate::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_setter(&self) -> Option<Setter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Setter::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_setter(&self) -> Vec<Setter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Setter::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_constraints(&self) -> Option<TypeConstraints> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeConstraints::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_constraints(&self) -> Vec<TypeConstraints> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeConstraints::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_modifiers(&self) -> Option<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_modifiers(&self) -> Vec<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_parameters(&self) -> Option<TypeParameters> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeParameters::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_parameters(&self) -> Vec<TypeParameters> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeParameters::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_user_type(&self) -> Option<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_user_type(&self) -> Vec<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_variable_declaration(&self) -> Option<VariableDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| VariableDeclaration::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_variable_declaration(&self) -> Vec<VariableDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| VariableDeclaration::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for PropertyDeclaration<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct PropertyDelegate<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> PropertyDelegate<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for PropertyDelegate<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct RangeExpression<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> RangeExpression<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for RangeExpression<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct RangeTest<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> RangeTest<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for RangeTest<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct SecondaryConstructor<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> SecondaryConstructor<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_constructor_delegation_call(&self) -> Option<ConstructorDelegationCall> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConstructorDelegationCall::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_constructor_delegation_call(&self) -> Vec<ConstructorDelegationCall> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConstructorDelegationCall::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_function_value_parameters(&self) -> Option<FunctionValueParameters> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionValueParameters::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_value_parameters(&self) -> Vec<FunctionValueParameters> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionValueParameters::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_modifiers(&self) -> Option<Modifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Modifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_modifiers(&self) -> Vec<Modifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Modifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_statements(&self) -> Option<Statements> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Statements::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_statements(&self) -> Vec<Statements> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Statements::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for SecondaryConstructor<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct Setter<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> Setter<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_function_body(&self) -> Option<FunctionBody> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionBody::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_body(&self) -> Vec<FunctionBody> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionBody::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_function_type(&self) -> Option<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_type(&self) -> Vec<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_modifiers(&self) -> Option<Modifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Modifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_modifiers(&self) -> Vec<Modifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Modifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_not_nullable_type(&self) -> Option<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_not_nullable_type(&self) -> Vec<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_nullable_type(&self) -> Option<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_nullable_type(&self) -> Vec<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parameter_with_optional_type(&self) -> Option<ParameterWithOptionalType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParameterWithOptionalType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parameter_with_optional_type(&self) -> Vec<ParameterWithOptionalType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParameterWithOptionalType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_type(&self) -> Option<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_type(&self) -> Vec<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_modifiers(&self) -> Option<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_modifiers(&self) -> Vec<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_user_type(&self) -> Option<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_user_type(&self) -> Vec<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for Setter<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct ShebangLine<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> ShebangLine<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }}

impl<'a> std::fmt::Debug for ShebangLine<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct SimpleIdentifier<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> SimpleIdentifier<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }}

impl<'a> std::fmt::Debug for SimpleIdentifier<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct SourceFile<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> SourceFile<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_annotation(&self) -> Option<Annotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Annotation::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_annotation(&self) -> Vec<Annotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Annotation::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_assignment(&self) -> Option<Assignment> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Assignment::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_assignment(&self) -> Vec<Assignment> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Assignment::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_class_declaration(&self) -> Option<ClassDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ClassDeclaration::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_class_declaration(&self) -> Vec<ClassDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ClassDeclaration::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_do_while_statement(&self) -> Option<DoWhileStatement> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DoWhileStatement::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_do_while_statement(&self) -> Vec<DoWhileStatement> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DoWhileStatement::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_file_annotation(&self) -> Option<FileAnnotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FileAnnotation::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_file_annotation(&self) -> Vec<FileAnnotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FileAnnotation::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_for_statement(&self) -> Option<ForStatement> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ForStatement::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_for_statement(&self) -> Vec<ForStatement> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ForStatement::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_function_declaration(&self) -> Option<FunctionDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionDeclaration::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_declaration(&self) -> Vec<FunctionDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionDeclaration::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_getter(&self) -> Option<Getter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Getter::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_getter(&self) -> Vec<Getter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Getter::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_import_list(&self) -> Option<ImportList> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ImportList::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_import_list(&self) -> Vec<ImportList> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ImportList::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_label(&self) -> Option<Label> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Label::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_label(&self) -> Vec<Label> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Label::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_declaration(&self) -> Option<ObjectDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectDeclaration::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_declaration(&self) -> Vec<ObjectDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectDeclaration::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_package_header(&self) -> Option<PackageHeader> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PackageHeader::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_package_header(&self) -> Vec<PackageHeader> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PackageHeader::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_property_declaration(&self) -> Option<PropertyDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PropertyDeclaration::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_property_declaration(&self) -> Vec<PropertyDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PropertyDeclaration::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_setter(&self) -> Option<Setter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Setter::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_setter(&self) -> Vec<Setter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Setter::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_shebang_line(&self) -> Option<ShebangLine> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ShebangLine::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_shebang_line(&self) -> Vec<ShebangLine> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ShebangLine::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_alias(&self) -> Option<TypeAlias> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeAlias::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_alias(&self) -> Vec<TypeAlias> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeAlias::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_while_statement(&self) -> Option<WhileStatement> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhileStatement::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_while_statement(&self) -> Vec<WhileStatement> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhileStatement::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for SourceFile<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct SpreadExpression<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> SpreadExpression<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for SpreadExpression<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct Statements<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> Statements<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_annotation(&self) -> Option<Annotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Annotation::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_annotation(&self) -> Vec<Annotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Annotation::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_assignment(&self) -> Option<Assignment> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Assignment::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_assignment(&self) -> Vec<Assignment> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Assignment::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_class_declaration(&self) -> Option<ClassDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ClassDeclaration::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_class_declaration(&self) -> Vec<ClassDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ClassDeclaration::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_do_while_statement(&self) -> Option<DoWhileStatement> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DoWhileStatement::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_do_while_statement(&self) -> Vec<DoWhileStatement> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DoWhileStatement::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_for_statement(&self) -> Option<ForStatement> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ForStatement::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_for_statement(&self) -> Vec<ForStatement> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ForStatement::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_function_declaration(&self) -> Option<FunctionDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionDeclaration::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_declaration(&self) -> Vec<FunctionDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionDeclaration::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_getter(&self) -> Option<Getter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Getter::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_getter(&self) -> Vec<Getter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Getter::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_label(&self) -> Option<Label> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Label::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_label(&self) -> Vec<Label> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Label::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_declaration(&self) -> Option<ObjectDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectDeclaration::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_declaration(&self) -> Vec<ObjectDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectDeclaration::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_property_declaration(&self) -> Option<PropertyDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PropertyDeclaration::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_property_declaration(&self) -> Vec<PropertyDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PropertyDeclaration::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_setter(&self) -> Option<Setter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Setter::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_setter(&self) -> Vec<Setter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Setter::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_alias(&self) -> Option<TypeAlias> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeAlias::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_alias(&self) -> Vec<TypeAlias> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeAlias::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_while_statement(&self) -> Option<WhileStatement> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhileStatement::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_while_statement(&self) -> Vec<WhileStatement> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhileStatement::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for Statements<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct StringLiteral<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> StringLiteral<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_interpolated_expression(&self) -> Option<InterpolatedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InterpolatedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_interpolated_expression(&self) -> Vec<InterpolatedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InterpolatedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_interpolated_identifier(&self) -> Option<InterpolatedIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InterpolatedIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_interpolated_identifier(&self) -> Vec<InterpolatedIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InterpolatedIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_content(&self) -> Option<StringContent> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringContent::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_content(&self) -> Vec<StringContent> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringContent::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for StringLiteral<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct SuperExpression<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> SuperExpression<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_function_type(&self) -> Option<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_type(&self) -> Vec<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_not_nullable_type(&self) -> Option<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_not_nullable_type(&self) -> Vec<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_nullable_type(&self) -> Option<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_nullable_type(&self) -> Vec<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_type(&self) -> Option<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_type(&self) -> Vec<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_identifier(&self) -> Option<TypeIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_identifier(&self) -> Vec<TypeIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_modifiers(&self) -> Option<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_modifiers(&self) -> Vec<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_user_type(&self) -> Option<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_user_type(&self) -> Vec<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for SuperExpression<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct ThisExpression<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> ThisExpression<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_type_identifier(&self) -> Option<TypeIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_identifier(&self) -> Vec<TypeIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for ThisExpression<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct TryExpression<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> TryExpression<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_catch_block(&self) -> Option<CatchBlock> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CatchBlock::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_catch_block(&self) -> Vec<CatchBlock> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CatchBlock::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_finally_block(&self) -> Option<FinallyBlock> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FinallyBlock::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_finally_block(&self) -> Vec<FinallyBlock> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FinallyBlock::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_statements(&self) -> Option<Statements> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Statements::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_statements(&self) -> Vec<Statements> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Statements::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for TryExpression<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct TypeAlias<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> TypeAlias<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_function_type(&self) -> Option<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_type(&self) -> Vec<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_modifiers(&self) -> Option<Modifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Modifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_modifiers(&self) -> Vec<Modifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Modifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_not_nullable_type(&self) -> Option<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_not_nullable_type(&self) -> Vec<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_nullable_type(&self) -> Option<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_nullable_type(&self) -> Vec<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_type(&self) -> Option<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_type(&self) -> Vec<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_identifier(&self) -> Option<TypeIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_identifier(&self) -> Vec<TypeIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_modifiers(&self) -> Option<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_modifiers(&self) -> Vec<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_parameters(&self) -> Option<TypeParameters> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeParameters::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_parameters(&self) -> Vec<TypeParameters> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeParameters::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_user_type(&self) -> Option<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_user_type(&self) -> Vec<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for TypeAlias<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct TypeArguments<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> TypeArguments<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_type_projection(&self) -> Option<TypeProjection> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeProjection::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_projection(&self) -> Vec<TypeProjection> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeProjection::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for TypeArguments<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct TypeConstraint<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> TypeConstraint<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_annotation(&self) -> Option<Annotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Annotation::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_annotation(&self) -> Vec<Annotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Annotation::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_function_type(&self) -> Option<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_type(&self) -> Vec<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_not_nullable_type(&self) -> Option<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_not_nullable_type(&self) -> Vec<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_nullable_type(&self) -> Option<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_nullable_type(&self) -> Vec<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_type(&self) -> Option<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_type(&self) -> Vec<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_identifier(&self) -> Option<TypeIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_identifier(&self) -> Vec<TypeIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_modifiers(&self) -> Option<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_modifiers(&self) -> Vec<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_user_type(&self) -> Option<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_user_type(&self) -> Vec<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for TypeConstraint<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct TypeConstraints<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> TypeConstraints<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_type_constraint(&self) -> Option<TypeConstraint> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeConstraint::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_constraint(&self) -> Vec<TypeConstraint> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeConstraint::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for TypeConstraints<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct TypeIdentifier<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> TypeIdentifier<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }}

impl<'a> std::fmt::Debug for TypeIdentifier<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct TypeModifiers<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> TypeModifiers<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_annotation(&self) -> Option<Annotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Annotation::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_annotation(&self) -> Vec<Annotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Annotation::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for TypeModifiers<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct TypeParameter<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> TypeParameter<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_function_type(&self) -> Option<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_type(&self) -> Vec<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_not_nullable_type(&self) -> Option<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_not_nullable_type(&self) -> Vec<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_nullable_type(&self) -> Option<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_nullable_type(&self) -> Vec<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_type(&self) -> Option<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_type(&self) -> Vec<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_identifier(&self) -> Option<TypeIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_identifier(&self) -> Vec<TypeIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_modifiers(&self) -> Option<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_modifiers(&self) -> Vec<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_parameter_modifiers(&self) -> Option<TypeParameterModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeParameterModifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_parameter_modifiers(&self) -> Vec<TypeParameterModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeParameterModifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_user_type(&self) -> Option<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_user_type(&self) -> Vec<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for TypeParameter<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct TypeParameterModifiers<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> TypeParameterModifiers<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_annotation(&self) -> Option<Annotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Annotation::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_annotation(&self) -> Vec<Annotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Annotation::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_reification_modifier(&self) -> Option<ReificationModifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ReificationModifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_reification_modifier(&self) -> Vec<ReificationModifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ReificationModifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_variance_modifier(&self) -> Option<VarianceModifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| VarianceModifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_variance_modifier(&self) -> Vec<VarianceModifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| VarianceModifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for TypeParameterModifiers<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct TypeParameters<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> TypeParameters<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_type_parameter(&self) -> Option<TypeParameter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeParameter::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_parameter(&self) -> Vec<TypeParameter> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeParameter::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for TypeParameters<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct TypeProjection<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> TypeProjection<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_function_type(&self) -> Option<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_type(&self) -> Vec<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_not_nullable_type(&self) -> Option<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_not_nullable_type(&self) -> Vec<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_nullable_type(&self) -> Option<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_nullable_type(&self) -> Vec<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_type(&self) -> Option<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_type(&self) -> Vec<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_modifiers(&self) -> Option<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_modifiers(&self) -> Vec<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_projection_modifiers(&self) -> Option<TypeProjectionModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeProjectionModifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_projection_modifiers(&self) -> Vec<TypeProjectionModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeProjectionModifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_user_type(&self) -> Option<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_user_type(&self) -> Vec<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for TypeProjection<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct TypeProjectionModifiers<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> TypeProjectionModifiers<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_variance_modifier(&self) -> Option<VarianceModifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| VarianceModifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_variance_modifier(&self) -> Vec<VarianceModifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| VarianceModifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for TypeProjectionModifiers<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct TypeTest<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> TypeTest<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_function_type(&self) -> Option<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_type(&self) -> Vec<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_not_nullable_type(&self) -> Option<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_not_nullable_type(&self) -> Vec<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_nullable_type(&self) -> Option<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_nullable_type(&self) -> Vec<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_type(&self) -> Option<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_type(&self) -> Vec<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_modifiers(&self) -> Option<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_modifiers(&self) -> Vec<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_user_type(&self) -> Option<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_user_type(&self) -> Vec<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for TypeTest<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct UnsignedLiteral<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> UnsignedLiteral<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for UnsignedLiteral<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct UseSiteTarget<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> UseSiteTarget<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }}

impl<'a> std::fmt::Debug for UseSiteTarget<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct UserType<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> UserType<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_type_arguments(&self) -> Option<TypeArguments> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeArguments::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_arguments(&self) -> Vec<TypeArguments> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeArguments::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_identifier(&self) -> Option<TypeIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_identifier(&self) -> Vec<TypeIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for UserType<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct ValueArgument<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> ValueArgument<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_annotation(&self) -> Option<Annotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Annotation::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_annotation(&self) -> Vec<Annotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Annotation::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for ValueArgument<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct ValueArguments<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> ValueArguments<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_value_argument(&self) -> Option<ValueArgument> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ValueArgument::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_value_argument(&self) -> Vec<ValueArgument> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ValueArgument::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for ValueArguments<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct VariableDeclaration<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> VariableDeclaration<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_function_type(&self) -> Option<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_function_type(&self) -> Vec<FunctionType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| FunctionType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_not_nullable_type(&self) -> Option<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_not_nullable_type(&self) -> Vec<NotNullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NotNullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_nullable_type(&self) -> Option<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_nullable_type(&self) -> Vec<NullableType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullableType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_type(&self) -> Option<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_type(&self) -> Vec<ParenthesizedType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_modifiers(&self) -> Option<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_modifiers(&self) -> Vec<TypeModifiers> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeModifiers::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_user_type(&self) -> Option<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UserType::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_user_type(&self) -> Vec<UserType> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UserType::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for VariableDeclaration<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct VarianceModifier<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> VarianceModifier<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }}

impl<'a> std::fmt::Debug for VarianceModifier<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct VisibilityModifier<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> VisibilityModifier<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }}

impl<'a> std::fmt::Debug for VisibilityModifier<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct WhenCondition<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> WhenCondition<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_test(&self) -> Option<RangeTest> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeTest::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_test(&self) -> Vec<RangeTest> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeTest::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_type_test(&self) -> Option<TypeTest> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeTest::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_type_test(&self) -> Vec<TypeTest> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TypeTest::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for WhenCondition<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct WhenEntry<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> WhenEntry<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_control_structure_body(&self) -> Option<ControlStructureBody> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ControlStructureBody::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_control_structure_body(&self) -> Vec<ControlStructureBody> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ControlStructureBody::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_condition(&self) -> Option<WhenCondition> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenCondition::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_condition(&self) -> Vec<WhenCondition> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenCondition::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for WhenEntry<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct WhenExpression<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> WhenExpression<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_when_entry(&self) -> Option<WhenEntry> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenEntry::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_entry(&self) -> Vec<WhenEntry> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenEntry::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_subject(&self) -> Option<WhenSubject> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenSubject::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_subject(&self) -> Vec<WhenSubject> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenSubject::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for WhenExpression<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct WhenSubject<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> WhenSubject<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_annotation(&self) -> Option<Annotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Annotation::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_annotation(&self) -> Vec<Annotation> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| Annotation::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_variable_declaration(&self) -> Option<VariableDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| VariableDeclaration::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_variable_declaration(&self) -> Vec<VariableDeclaration> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| VariableDeclaration::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for WhenSubject<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct WhileStatement<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> WhileStatement<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }
    pub fn find_additive_expression(&self) -> Option<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_additive_expression(&self) -> Vec<AdditiveExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AdditiveExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_anonymous_function(&self) -> Option<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_anonymous_function(&self) -> Vec<AnonymousFunction> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AnonymousFunction::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_as_expression(&self) -> Option<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_as_expression(&self) -> Vec<AsExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| AsExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_bin_literal(&self) -> Option<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_bin_literal(&self) -> Vec<BinLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BinLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_boolean_literal(&self) -> Option<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_boolean_literal(&self) -> Vec<BooleanLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| BooleanLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_call_expression(&self) -> Option<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_call_expression(&self) -> Vec<CallExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_callable_reference(&self) -> Option<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_callable_reference(&self) -> Vec<CallableReference> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CallableReference::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_character_literal(&self) -> Option<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_character_literal(&self) -> Vec<CharacterLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CharacterLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_check_expression(&self) -> Option<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_check_expression(&self) -> Vec<CheckExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CheckExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_collection_literal(&self) -> Option<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_collection_literal(&self) -> Vec<CollectionLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| CollectionLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_comparison_expression(&self) -> Option<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_comparison_expression(&self) -> Vec<ComparisonExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ComparisonExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_conjunction_expression(&self) -> Option<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_conjunction_expression(&self) -> Vec<ConjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ConjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_control_structure_body(&self) -> Option<ControlStructureBody> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ControlStructureBody::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_control_structure_body(&self) -> Vec<ControlStructureBody> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ControlStructureBody::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_disjunction_expression(&self) -> Option<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_disjunction_expression(&self) -> Vec<DisjunctionExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| DisjunctionExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_elvis_expression(&self) -> Option<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_elvis_expression(&self) -> Vec<ElvisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ElvisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_equality_expression(&self) -> Option<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_equality_expression(&self) -> Vec<EqualityExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| EqualityExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_hex_literal(&self) -> Option<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_hex_literal(&self) -> Vec<HexLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| HexLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_if_expression(&self) -> Option<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_if_expression(&self) -> Vec<IfExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IfExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_indexing_expression(&self) -> Option<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_indexing_expression(&self) -> Vec<IndexingExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IndexingExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_infix_expression(&self) -> Option<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_infix_expression(&self) -> Vec<InfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| InfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_integer_literal(&self) -> Option<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_integer_literal(&self) -> Vec<IntegerLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| IntegerLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_jump_expression(&self) -> Option<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_jump_expression(&self) -> Vec<JumpExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| JumpExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_lambda_literal(&self) -> Option<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_lambda_literal(&self) -> Vec<LambdaLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LambdaLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_long_literal(&self) -> Option<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_long_literal(&self) -> Vec<LongLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| LongLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_multiplicative_expression(&self) -> Option<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_multiplicative_expression(&self) -> Vec<MultiplicativeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| MultiplicativeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_navigation_expression(&self) -> Option<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_navigation_expression(&self) -> Vec<NavigationExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NavigationExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_null_literal(&self) -> Option<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_null_literal(&self) -> Vec<NullLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| NullLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_object_literal(&self) -> Option<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_object_literal(&self) -> Vec<ObjectLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ObjectLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_parenthesized_expression(&self) -> Option<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_parenthesized_expression(&self) -> Vec<ParenthesizedExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ParenthesizedExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_postfix_expression(&self) -> Option<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_postfix_expression(&self) -> Vec<PostfixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PostfixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_prefix_expression(&self) -> Option<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_prefix_expression(&self) -> Vec<PrefixExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| PrefixExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_range_expression(&self) -> Option<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_range_expression(&self) -> Vec<RangeExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RangeExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_real_literal(&self) -> Option<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_real_literal(&self) -> Vec<RealLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| RealLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_simple_identifier(&self) -> Option<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_simple_identifier(&self) -> Vec<SimpleIdentifier> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SimpleIdentifier::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_spread_expression(&self) -> Option<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_spread_expression(&self) -> Vec<SpreadExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SpreadExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_string_literal(&self) -> Option<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_string_literal(&self) -> Vec<StringLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| StringLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_super_expression(&self) -> Option<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_super_expression(&self) -> Vec<SuperExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| SuperExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_this_expression(&self) -> Option<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_this_expression(&self) -> Vec<ThisExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| ThisExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_try_expression(&self) -> Option<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_try_expression(&self) -> Vec<TryExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| TryExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_unsigned_literal(&self) -> Option<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_unsigned_literal(&self) -> Vec<UnsignedLiteral> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| UnsignedLiteral::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }
    pub fn find_when_expression(&self) -> Option<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .next();
        x
    }

    pub fn find_all_when_expression(&self) -> Vec<WhenExpression> {
        let mut cursor = self.node.walk();
        let x = self
            .node
            .children(&mut cursor)
            .filter(|n| n.kind() == "type_identifier")
            .map(|n| WhenExpression::new(n.clone(), &self.source))
            .collect::<Vec<_>>();
        x
    }}

impl<'a> std::fmt::Debug for WhileStatement<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct BinLiteral<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> BinLiteral<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }}

impl<'a> std::fmt::Debug for BinLiteral<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct HexLiteral<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> HexLiteral<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }}

impl<'a> std::fmt::Debug for HexLiteral<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct IntegerLiteral<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> IntegerLiteral<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }}

impl<'a> std::fmt::Debug for IntegerLiteral<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct LineComment<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> LineComment<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }}

impl<'a> std::fmt::Debug for LineComment<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct MultilineComment<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> MultilineComment<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }}

impl<'a> std::fmt::Debug for MultilineComment<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct NullLiteral<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> NullLiteral<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }}

impl<'a> std::fmt::Debug for NullLiteral<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct PropertyModifier<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> PropertyModifier<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }}

impl<'a> std::fmt::Debug for PropertyModifier<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct RealLiteral<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> RealLiteral<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }}

impl<'a> std::fmt::Debug for RealLiteral<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct ReificationModifier<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> ReificationModifier<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }}

impl<'a> std::fmt::Debug for ReificationModifier<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct StringContent<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> StringContent<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }}

impl<'a> std::fmt::Debug for StringContent<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}pub struct WildcardImport<'a> {
    pub node: Node<'a>,
    pub source: &'a Rope,
}

impl<'a> WildcardImport<'a> {
    pub fn new(node: Node<'a>, source: &'a Rope) -> Self {
        Self{node, source}
    }
    pub fn text(&self) -> String {
        text_of(&self.node, self.source)
    }}

impl<'a> std::fmt::Debug for WildcardImport<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.text())
    }
}